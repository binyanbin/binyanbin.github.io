<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 电商面试题 · bindog</title><meta name="description" content="电商 抢购 超卖"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/binyanbin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">电商面试题</h1><div class="post-meta"><div class="post-time">2016年2月18日</div></div><div class="post-content"><p>15年年底去一家电商服务公司面试，其中有一道题目是如何解决电商站点商品秒杀的相关问题。<a href="https://github.com/hishopdc/dc2015" target="_blank" rel="external">示例题目可以参见</a>。固定的数据库结构下实现三个接口，查看、下单、付款。<br><a id="more"></a></p>
<h2 id="u4E3B_u8981_u95EE_u9898_3A_u9AD8_u5E76_u53D1_u67E5_u8BE2_u53CA_u66F4_u65B0_u6570_u636E_u5E93"><a href="#u4E3B_u8981_u95EE_u9898_3A_u9AD8_u5E76_u53D1_u67E5_u8BE2_u53CA_u66F4_u65B0_u6570_u636E_u5E93" class="headerlink" title="主要问题:高并发查询及更新数据库"></a>主要问题:高并发查询及更新数据库</h2><p>解决的方案其实比较其实并不复杂，也很常规。无非就是用缓存队列实现批量更新数据库。把下单的数据放入队列中，然后批量更新到数据库中去。说起来比较简单，实践中还是踩了一些坑。</p>
<h3 id="u4E3B_u8981_u5B9E_u73B0_u903B_u8F91"><a href="#u4E3B_u8981_u5B9E_u73B0_u903B_u8F91" class="headerlink" title="主要实现逻辑"></a>主要实现逻辑</h3><p>订单处理类<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#35746;&#21333;&#32531;&#23384;&#38431;&#21015;&#22788;&#29702;&#31867;&#10;/// &#60;/summary&#62;&#10;public class OrderCacheQuene&#10;&#123;&#10;    /// &#60;summary&#62;&#10;    /// &#35746;&#21333;&#38431;&#21015;&#32531;&#23384;&#10;    /// &#60;/summary&#62;&#10;    private static List&#60;Order&#62; _orders;&#10;    /// &#60;summary&#62;&#10;    /// &#25968;&#25454;&#24211;&#25805;&#20316;&#25509;&#21475;&#10;    /// &#60;/summary&#62;&#10;    private static IPromotion _service;&#10;    /// &#60;summary&#62;&#10;    /// &#38145;&#10;    /// &#60;/summary&#62;&#10;    private static object _locker = new object();&#10;    /// &#60;summary&#62;&#10;    /// &#38431;&#21015;&#22788;&#29702;&#32447;&#31243;&#10;    /// &#60;/summary&#62;&#10;    private static Thread _thread;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#35746;&#21333;&#38431;&#21015;&#21551;&#21160;&#10;    /// &#60;/summary&#62;&#10;    public static void Start()&#10;    &#123;&#10;        _thread = new Thread(new ThreadStart(OrderDispose));&#10;        _thread.Start();&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#32531;&#23384;&#32467;&#26463;&#10;    /// &#60;/summary&#62;&#10;    public static void End()&#10;    &#123;&#10;        lock (_locker)&#10;        &#123;&#10;            _thread.Abort();&#10;            _service.OrderTrans(_orders);&#10;            _orders.Clear();&#10;        &#125;&#10;    &#125;&#10;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#19979;&#21333;&#10;    /// &#60;/summary&#62;&#10;    public static string OrderBuy(Order o)&#10;    &#123;&#10;        lock (_locker)&#10;        &#123;&#10;            _orders.Add(o);&#10;        &#125;&#10;        return o.OrderId;&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#25903;&#20184;&#10;    /// &#60;/summary&#62;&#10;    public static bool OrderPay(RequestPay o, DateTime? paytime)&#10;    &#123;&#10;        lock (_locker)&#10;        &#123;&#10;        &#9;Order order = null;&#10;            int index = _orders.FindIndex(t =&#62; t.OrderId == o.order_id &#38;&#38; t.UserId == o.uid);&#10;            if (index &#62;= 0)///&#24050;&#23384;&#22312;&#32531;&#23384;&#20013;&#10;            &#123;&#10;                _orders[index].PayTime = paytime;&#10;                return true;&#10;            &#125;            &#9;&#10;            order = _service.GetOrder(o.order_id);&#10;            if (order == null)&#10;                return false;&#10;            else///&#24050;&#23384;&#22312;&#25968;&#25454;&#24211;&#20013;&#10;            &#123;&#10;                order.PayTime = paytime;&#10;                lock (_locker)&#10;                &#123;&#10;                    _orders.Add(order);&#10;                &#125;&#10;                return true;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#21028;&#26029;&#38431;&#21015;&#26159;&#21542;&#24050;&#28385;&#10;    /// &#60;/summary&#62;&#10;    public static bool isFull()&#10;    &#123;&#10;        return _orders.Count &#62;= Constant.QueueMaxCount ? true : false;&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#35746;&#21333;&#38431;&#21015;&#22788;&#29702;&#20107;&#20214;&#10;    /// &#60;/summary&#62;&#10;    private static void OrderDispose()&#10;    &#123;&#10;        while (true)&#10;        &#123;&#10;            //DateTime starttime = DateTime.Now;&#10;            lock (_locker)&#10;            &#123;&#10;               List&#60;Order&#62; orders =  _orders.Take(Constant.MaxOrderDispose).ToList();&#10;                _service.OrderTrans(orders.ToList());//&#35843;&#29992;&#25968;&#25454;&#24211;&#25509;&#21475;&#22788;&#29702;&#35746;&#21333;&#10;                foreach (Order o in orders)&#10;                    _orders.Remove(o);&#10;            &#125;&#10;            Thread.Sleep(Constant.QueueDisposeTimeSpan);//&#27599;&#27425;&#22788;&#29702;&#23436;&#25104;&#20241;&#30496;&#10;            //DateTime endtime = DateTime.Now;&#10;            //System.Diagnostics.Debug.WriteLine(&#34;Yanbin TimeSpan:&#34;+endtime.Subtract(starttime).Milliseconds);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>订单队列启动<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> public class WebApiApplication : System.Web.HttpApplication&#10; &#123;&#10;protected void Application_Start()&#10;     &#123;&#10;&#10;         //&#35746;&#21333;&#38431;&#21015;&#21551;&#21160;&#10;         OrderCacheQuene.Start();&#10;     &#125;&#10; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u57511_3A_u8D85_u5356"><a href="#u57511_3A_u8D85_u5356" class="headerlink" title="坑1:超卖"></a>坑1:超卖</h3><p>程序实现以后，我写了一个测试程序去跑它，跑到1000线程时超卖了，思来想去之后发现判断的问题，开始下单时的判断条件没有放到订单队列程序里面。所以有时间判断的时候之前，有一些订单就到缓存中去了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#19979;&#21333;&#10;/// &#60;/summary&#62;&#10;public static string OrderBuy(Order o)&#10;&#123;&#10;    if (&#38431;&#21015;&#24050;&#28385;&#65292;&#24050;&#21334;&#31354;&#65292;&#24050;&#19979;&#21333;&#31561;&#26465;&#20214;)&#10;    &#9;return null;&#10;    lock (_locker)&#10;    &#123;&#10;&#10;        _orders.Add(o);&#10;    &#125;&#10;    return o.OrderId;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u57512_3A_u6548_u7387_u5751"><a href="#u57512_3A_u6548_u7387_u5751" class="headerlink" title="坑2:效率坑"></a>坑2:效率坑</h3><p>做web接口，在.net的系统中当然用webapi,更种好处用过都知道，没想到在高并发的条件下效率不如handler。以下这些数据是在我这台旧的笔记本上测试出来的。</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程调用接口数</th>
<th>处理方式</th>
<th>说明</th>
<th>产生订单数</th>
<th>接口方式</th>
<th>完成时间(秒)</th>
<th>完成时间(分钟)</th>
<th>处理请求总数</th>
<th>平均每秒处理请求</th>
</tr>
</thead>
<tbody>
<tr>
<td>2000</td>
<td>100</td>
<td>只查询</td>
<td>2000人同时查100种商品</td>
<td>0</td>
<td>handler</td>
<td>650.5</td>
<td>10.84</td>
<td>199706</td>
<td>307.004</td>
</tr>
<tr>
<td>2000</td>
<td>100</td>
<td>只查询</td>
<td>2000人同时查100种商品</td>
<td>0</td>
<td>api</td>
<td>1180.8</td>
<td>19.68</td>
<td>199747</td>
<td>169.162</td>
</tr>
<tr>
<td>1000</td>
<td>50</td>
<td>只查询</td>
<td>1000人同时查50种商品</td>
<td>0</td>
<td>handler</td>
<td>86.3</td>
<td>1.44</td>
<td>49932</td>
<td>578.586</td>
</tr>
<tr>
<td>1000</td>
<td>50</td>
<td>只查询</td>
<td>1000人同时查50种商品</td>
<td>0</td>
<td>api</td>
<td>103.9</td>
<td>1.73</td>
<td>49948</td>
<td>480.731</td>
</tr>
<tr>
<td>2000</td>
<td>10</td>
<td>抢购</td>
<td>2000人抢100个订单</td>
<td>100</td>
<td>handler</td>
<td>81.9</td>
<td>1.37</td>
<td>40430</td>
<td>493.651</td>
</tr>
<tr>
<td>2000</td>
<td>10</td>
<td>抢购</td>
<td>2000人抢100个订单</td>
<td>100</td>
<td>api</td>
<td>79.7</td>
<td>1.33</td>
<td>28738</td>
<td>360.577</td>
</tr>
<tr>
<td>2000</td>
<td>50</td>
<td>并发购买</td>
<td>50个人同时买2000种不同商品</td>
<td>100000</td>
<td>Handler</td>
<td>3467    57.78</td>
<td>299471</td>
<td>86.378</td>
</tr>
<tr>
<td>2000</td>
<td>50</td>
<td>并发购买</td>
<td>50个人同时买2000种不同商品</td>
<td>100000</td>
<td>api</td>
<td>3638</td>
<td>60.63</td>
<td>299375</td>
<td>82.291</td>
</tr>
</tbody>
</table>
<p>从上图可以看出，在高并发情况下webapi的性能确实不行。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/01/hello-world/" class="next">下一篇</a></div><div data-thread-key="2016/02/18/interview-hishop/" data-title="电商面试题" data-url="http://binyanbin.github.io/2016/02/18/interview-hishop/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"binyanbin"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://binyanbin.github.io">bindog</a>, unless otherwise noted.</p></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?fcf7e8f303b6e03be86f5619636d0f7e";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>