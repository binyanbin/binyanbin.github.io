<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 码工严彬 coding不仅仅是工作</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/binyanbin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/2015/12/20/self-introduce/" target="_self" class="nav-list-link">INDEX</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/13/c-6/" class="post-title-link">C语言之socket 简易客户端</a></h2><div class="post-meta"><div class="post-time">2016年4月13日</div></div><div class="post-content"><p>昨天做了一个简易服务端，今天尝试做一个简易客户端，东西比较少，很顺利就完成了。客户端socket操作步骤:1.创建socket 2.连接服务端 3.接收服务端返回数据</p>
<h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><p>1.连接:<br>int connect(int fd, const struct sockaddr* addr, socklen_t address_len));<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>address_len：确定address缓冲区的长度<br>返回值：如果函数执行成功，返回值为0，否则为-1。</p>
<p>2.接收<br>int recv(SOCKET socket, char FAR* buf, int len, int flags);<br>socket：一个标识已连接套接口的描述字。<br>buf：用于接收数据的缓冲区。<br>len：缓冲区长度。<br>flags：指定调用方式。<br>返回值：若无错误发生,recv()返回读入的字节数.如果连接已中止，返回0.否则的话,返回SOCKET_ERROR错误.</p></div><a href="2016/04/13/c-6/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/12/c-5/" class="post-title-link">C语言之socket 简易服务端</a></h2><div class="post-meta"><div class="post-time">2016年4月12日</div></div><div class="post-content"><p>今年有两个目标，一个是做开源项目，第二个是用C写一个网络服务。C写网络服务Socket是基础，首先需要了解socket的用法。服务端socket操作步骤:1.创建socket,2.绑定地址及端口,3.接收请求,4.发送数据。</p>
<h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><p>1.创建socket:<br>int socket(int domain, int type, int protocol);<br>domain：协议域<br>type：指定Socket类型。<br>protocol：指定协议。<br>返回值：如果调用成功就返回新创建的套接字的描述符，如果失败就返回-1。</p>
<p>2.绑定地址级端口<br>int bind(SOCKET socket, const struct sockaddr* address, socklen_t address_len);<br>参数说明：<br>socket：是一个套接字描述符。<br>address：是一个sockaddr结构指针，该结构中包含了要结合的地址和端口号。<br>address_len：确定address缓冲区的长度。<br>返回值：如果函数执行成功，返回值为0，否则为SOCKET_ERROR。</p>
<p>3.接收连接请求<br>int accept( int fd, struct socketaddr<em> addr, socklen_t</em> len);<br>参数说明：<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>len：接收返回地址的缓冲区长度<br>返回值：成功返回客户端的文件描述符，失败返回-1。</p>
<p>4.发送数据<br>int send(int fd, const void * msg, int len, unsigned int falgs);<br>fd：套接字描述符。<br>msg: 数据内容。<br>len: 数据长度。<br>返回值：成功则返回实际传送出去的字符数, 失败返回-1.</p></div><a href="2016/04/12/c-5/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/31/c-4/" class="post-title-link">C语言之函数库</a></h2><div class="post-meta"><div class="post-time">2016年3月31日</div></div><div class="post-content"></div><a href="2016/03/31/c-4/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/25/c-3/" class="post-title-link">C语言之由内存模型说起</a></h2><div class="post-meta"><div class="post-time">2016年3月25日</div></div><div class="post-content"><p>说起内存模型，那就先要介绍程序运行时是如何管理内存的。<br>程序运行时:</p>
<ul>
<li>系统先把物理硬盘代码load到内存</li>
<li>系统再把c代码分成四个区</li>
<li>系统再找到main函数入口执行<h2 id="u7A0B_u5E8F_u7684_u56DB_u533A_u6A21_u578B"><a href="#u7A0B_u5E8F_u7684_u56DB_u533A_u6A21_u578B" class="headerlink" title="程序的四区模型"></a>程序的四区模型</h2><img src="/img/c-3.png" alt="效果"></div><a href="2016/03/25/c-3/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/24/c-2/" class="post-title-link">C语言之个性化termial</a></h2><div class="post-meta"><div class="post-time">2016年3月24日</div></div><div class="post-content"><p>很多牛人有自己的个性化的命令行，为什么我没有呢?晚上我就写了一个。效果如下:<br><img src="/img/c-1.png" alt="效果"><br></div><a href="2016/03/24/c-2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/23/c-1/" class="post-title-link">C语言之编译器GCC</a></h2><div class="post-meta"><div class="post-time">2016年3月23日</div></div><div class="post-content"><h2 id="u4E3A_u4EC0_u4E48_u662FC"><a href="#u4E3A_u4EC0_u4E48_u662FC" class="headerlink" title="为什么是C"></a>为什么是C</h2><p>很多牛B的开源项目都是C实现的，如redis,nginx,memcache,node等等。主要原因是C语言比较简单(相对C++来说)，编译器稳定可靠。C如果借鉴一些良好设计,C一样可以写的很好，如果习惯了，开发效率未必会比C++低。那么C怎么编译呢?</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC(GNU Compiler Collection)，GNU编译器集合,是一套由 GNU 开发的编程语言编译器。其中包括了ANSI C Compiler。在现在遍地都是IDE的时代，很多开发人员都忘了怎么用cli去编译程序。gcc编译过程是分为四个阶段进行的，即预处理(也称预编译,Preprocessing)、编译(Compilation)、汇编(Assembly)和连接(Linking)。<br></div><a href="2016/03/23/c-1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/21/javascript-base-4/" class="post-title-link">Javascript模块化开发</a></h2><div class="post-meta"><div class="post-time">2016年3月21日</div></div><div class="post-content"><p>Javascript不算模块化编程语言，但是web开发需要团队开发和团队协做。现在javascript模块化开发已非常正熟，支持模块化开发的框架非常多。</p>
<h2 id="u539F_u59CB_u5199_u6CD5"><a href="#u539F_u59CB_u5199_u6CD5" class="headerlink" title="原始写法"></a>原始写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只要把不同的函数简单地放在一个文件中，就算是一个模块，通常一个文件一个模块。<br></div><a href="2016/03/21/javascript-base-4/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/12/jmeter-1/" class="post-title-link">jmeter 基础概念</a></h2><div class="post-meta"><div class="post-time">2016年3月12日</div></div><div class="post-content"><p>最近做性能优化工作，同时要给自己的工作给一个总结。需要自己弄性能测试及编写性能测试报告。在别人推荐下使用JMeter对项目进行性能测试。JMeter可以进行配置和执行负载测试、性能测试和压力测试的工具。了解一下几个概念:</p>
<ul>
<li>负载测试: 这类测试使系统或者应用程序在预先设计好的极端场景下测试运行。这类测试用来评估系统或者程序在极端条件下的行为。</li>
<li>性能测试: 这种测试被用来检测系统的性能表现，包括特定情况下，系统的响应能力和稳定性。</li>
<li>压力测试: 这类测试通过载入更多的外部资源，并使系统组件超越其所设定的能力范围,试图使系统挂掉.</div><a href="2016/03/12/jmeter-1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/10/redis-8/" class="post-title-link">redis学习8  Sentinel集群控制</a></h2><div class="post-meta"><div class="post-time">2016年3月10日</div></div><div class="post-content"><p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。<br></div><a href="2016/03/10/redis-8/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/09/redis-7/" class="post-title-link">redis学习7 主从复制</a></h2><div class="post-meta"><div class="post-time">2016年3月9日</div></div><div class="post-content"><p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。</div><a href="2016/03/09/redis-7/" class="read-more">...阅读全文</a></article></li></ul></section><footer><div class="paginator"><a href="/archives/2016/" class="prev">上一页</a><a href="/archives/2016/page/3/" class="next">下一页</a></div></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?fcf7e8f303b6e03be86f5619636d0f7e";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>