<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[码工严彬]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://binyanbin.github.io/"/>
  <updated>2016-03-23T14:29:35.363Z</updated>
  <id>http://binyanbin.github.io/</id>
  
  <author>
    <name><![CDATA[严彬]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C之GCC]]></title>
    <link href="http://binyanbin.github.io/2016/03/23/c-1/"/>
    <id>http://binyanbin.github.io/2016/03/23/c-1/</id>
    <published>2016-03-22T16:00:00.000Z</published>
    <updated>2016-03-23T14:29:35.363Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u662FC"><a href="#u4E3A_u4EC0_u4E48_u662FC" class="headerlink" title="为什么是C"></a>为什么是C</h2><p>很多牛B的开源项目都是C实现的，如redis,nginx,memcache,node等等。主要原因是C语言比较简单(相对C++来说)，编译器稳定可靠。C如果借鉴一些良好设计,C一样可以写的很好，如果习惯了，开发效率未必会比C++低。那么C怎么编译呢?</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC(GNU Compiler Collection)，GNU编译器集合,是一套由 GNU 开发的编程语言编译器。其中包括了ANSI C Compiler。在现在遍地都是IDE的时代，很多开发人员都忘了怎么用cli去编译程序。gcc编译过程是分为四个阶段进行的，即预处理(也称预编译,Preprocessing)、编译(Compilation)、汇编(Assembly)和连接(Linking)。<br><a id="more"></a></p>
<h4 id="u9884_u5904_u7406"><a href="#u9884_u5904_u7406" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。</p>
<h4 id="u7F16_u8BD1"><a href="#u7F16_u8BD1" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码。</p>
<h4 id="u6C47_u7F16"><a href="#u6C47_u7F16" class="headerlink" title="汇编"></a>汇编</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>
<p>汇编器可以将汇编代码编译为目标文件。</p>
<h4 id="u8FDE_u63A5"><a href="#u8FDE_u63A5" class="headerlink" title="连接"></a>连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p>
<h4 id="u7B80_u5355_u7F16_u8BD1"><a href="#u7B80_u5355_u7F16_u8BD1" class="headerlink" title="简单编译"></a>简单编译</h4><p>一步到位:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u591A_u4E2A_u7A0B_u5E8F_u6587_u4EF6_u7684_u7F16_u8BD1"><a href="#u591A_u4E2A_u7A0B_u5E8F_u6587_u4EF6_u7684_u7F16_u8BD1" class="headerlink" title="多个程序文件的编译"></a>多个程序文件的编译</h4><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c <span class="built_in">test</span>1.c -o <span class="built_in">test</span>1.o</span><br><span class="line">gcc -c <span class="built_in">test</span>2.c -o <span class="built_in">test</span>2.o</span><br><span class="line">gcc <span class="built_in">test</span>1.o <span class="built_in">test</span>2.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<h2 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h2><p>同样IDE的开发人员估计一般都不知道，IDE都为你做了这个工作。一个软件的代码文件是非常多的，如果你要自己一个个去写编译规则是相当复杂的。那么makefile就是解决整个软件的编译规则。一个软件项目中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了效率。</p>
<h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>MinGW是指只用自由软件来生成纯粹的Win32可执行文件的编译环境，它是Minimalist GNU on Windows的略称。</p>
<h4 id="u4E0B_u8F7DMinGW"><a href="#u4E0B_u8F7DMinGW" class="headerlink" title="下载MinGW"></a>下载MinGW</h4><p>到Sourceforge(<a href="http://sourceforge.net/project/showfiles.php?group_id=2435)下载一个MinGW.exe。" target="_blank" rel="external">http://sourceforge.net/project/showfiles.php?group_id=2435)下载一个MinGW.exe。</a></p>
<h4 id="u73AF_u5883_u53D8_u91CF_u7684_u914D_u7F6E"><a href="#u73AF_u5883_u53D8_u91CF_u7684_u914D_u7F6E" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h4><p>a.在PATH的值中加入“C:\MinGW\bin”。这是寻找gcc编译器的路径。如果PATH中还有其他内容，需要用英文状态下分号进行分割<br>b.新建LIBRARY_PATH变量，在其值中加入“C:\MinGW\lib”。这是标准库存放的路径。<br>c.新建C_INCLUDE_PATH变量，在其值中加入“C:\MinGW\include”。这是Include查找头文件的路径。</p>
<h4 id="u9A8C_u8BC1gcc_u662F_u5426_u6B63_u5E38_u8FD0_u884C"><a href="#u9A8C_u8BC1gcc_u662F_u5426_u6B63_u5E38_u8FD0_u884C" class="headerlink" title="验证gcc是否正常运行"></a>验证gcc是否正常运行</h4><p>在cmd控制台窗口下面,输入gcc -v.若已经成功安装好,会显示gcc的版本信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u662FC"><a href="#u4E3A_u4EC0_u4E48_u662FC" class="headerlink" title="为什么是C"></a>为什么是C</h2><p>很多牛B的开源项目都是C实现的，如redis,nginx,memcache,node等等。主要原因是C语言比较简单(相对C++来说)，编译器稳定可靠。C如果借鉴一些良好设计,C一样可以写的很好，如果习惯了，开发效率未必会比C++低。那么C怎么编译呢?</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC(GNU Compiler Collection)，GNU编译器集合,是一套由 GNU 开发的编程语言编译器。其中包括了ANSI C Compiler。在现在遍地都是IDE的时代，很多开发人员都忘了怎么用cli去编译程序。gcc编译过程是分为四个阶段进行的，即预处理(也称预编译,Preprocessing)、编译(Compilation)、汇编(Assembly)和连接(Linking)。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript模块化开发]]></title>
    <link href="http://binyanbin.github.io/2016/03/21/javascript-base-4/"/>
    <id>http://binyanbin.github.io/2016/03/21/javascript-base-4/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-03-21T14:25:18.781Z</updated>
    <content type="html"><![CDATA[<p>Javascript不算模块化编程语言，但是web开发需要团队开发和团队协做。现在javascript模块化开发已非常正熟，支持模块化开发的框架非常多。</p>
<h2 id="u539F_u59CB_u5199_u6CD5"><a href="#u539F_u59CB_u5199_u6CD5" class="headerlink" title="原始写法"></a>原始写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只要把不同的函数简单地放在一个文件中，就算是一个模块，通常一个文件一个模块。<br><a id="more"></a></p>
<h2 id="jquery_u65F6_u4EE3"><a href="#jquery_u65F6_u4EE3" class="headerlink" title="jquery时代"></a>jquery时代</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, windows</span>) </span>&#123;</span><br><span class="line">　　　　<span class="comment">//...</span></span><br><span class="line">　　&#125;)(jQuery, windows);</span><br></pre></td></tr></table></figure>
<p>通过立即执行匿名函数来达到封装的作用,如模块内部调用全局变量，则将其输入模块中。</p>
<h2 id="commonjs_u65F6_u4EE3"><a href="#commonjs_u65F6_u4EE3" class="headerlink" title="commonjs时代"></a>commonjs时代</h2><p>commonjs规范是目前JavaScript模块化的事实标准。支持commonjs规范的框架及程序比较多，如node,seajs.规范中最重要的二点:</p>
<ul>
<li>require它是一个函数,引用其它模块使用require。</li>
<li>exports是一个对象，导出模块api使用exports，可供其它模块调用。<br>当然除了这两点还有一些其它细节不一一介绍。下面看一个示例:</li>
</ul>
<p>math.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.add=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>increment.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>program.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inc = <span class="built_in">require</span>(<span class="string">'increment'</span>).increment;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">inc(a);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Javascript不算模块化编程语言，但是web开发需要团队开发和团队协做。现在javascript模块化开发已非常正熟，支持模块化开发的框架非常多。</p>
<h2 id="u539F_u59CB_u5199_u6CD5"><a href="#u539F_u59CB_u5199_u6CD5" class="headerlink" title="原始写法"></a>原始写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只要把不同的函数简单地放在一个文件中，就算是一个模块，通常一个文件一个模块。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[jmeter 基础概念]]></title>
    <link href="http://binyanbin.github.io/2016/03/12/jmeter-1/"/>
    <id>http://binyanbin.github.io/2016/03/12/jmeter-1/</id>
    <published>2016-03-11T16:00:00.000Z</published>
    <updated>2016-03-12T16:53:31.616Z</updated>
    <content type="html"><![CDATA[<p>最近做性能优化工作，同时要给自己的工作给一个总结。需要自己弄性能测试及编写性能测试报告。在别人推荐下使用JMeter对项目进行性能测试。JMeter可以进行配置和执行负载测试、性能测试和压力测试的工具。了解一下几个概念:</p>
<ul>
<li>负载测试: 这类测试使系统或者应用程序在预先设计好的极端场景下测试运行。这类测试用来评估系统或者程序在极端条件下的行为。</li>
<li>性能测试: 这种测试被用来检测系统的性能表现，包括特定情况下，系统的响应能力和稳定性。</li>
<li>压力测试: 这类测试通过载入更多的外部资源，并使系统组件超越其所设定的能力范围,试图使系统挂掉.<a id="more"></a>
JMeter 的安装非常简单,从官方网站上下载，解压之后即可使用。运行命令在%JMETER_HOME%/bin下,对于 Windows用户来说,命令是jmeter.bat。运行前请检查JMeter的文档,查看是否具备相关的运行条件:JDK的版本要求是否满足.<h2 id="Test_Plan_u914D_u7F6E"><a href="#Test_Plan_u914D_u7F6E" class="headerlink" title="Test Plan配置"></a>Test Plan配置</h2><img src="/img/jmeter-1.png" alt="基本配置"><br>进去之后，你会看到Test Plan和WorkBench。这两个块东西没有太多区别，不同的是Test Plan是测试的相关配置，workbench可以帮你创建一个代理服务器帮Test Plan录制测试脚本。<h4 id="ThreadGroup__u7EBF_u7A0B_u7EC4"><a href="#ThreadGroup__u7EBF_u7A0B_u7EC4" class="headerlink" title="ThreadGroup 线程组"></a>ThreadGroup 线程组</h4>一个线程组基本上是不同的测试计划元素的组合，它是一个测试计划的核心，它控制着基本核心参数。<br>为了创建一个测试计划，首先你不得不去创建一个线程组，配置如下参数:线程数量，过渡时期，循环次数和正常情况或者错误情况下的行为：<h4 id="Samplers__u91C7_u6837_u5668"><a href="#Samplers__u91C7_u6837_u5668" class="headerlink" title="Samplers 采样器"></a>Samplers 采样器</h4>采样器用于发送请求到不同类型的服务器。它们是每一个测试计划的基本要素，一切都围绕这些采样器而工作：采样器执行请求，这些请求产生一个或多个响应，后续将被分析。<h4 id="Logic_Controllers__u903B_u8F91_u63A7_u5236_u5668"><a href="#Logic_Controllers__u903B_u8F91_u63A7_u5236_u5668" class="headerlink" title="Logic Controllers 逻辑控制器"></a>Logic Controllers 逻辑控制器</h4>逻辑控制器允许你配置一个线程组内不同采样器的执行顺序。<h4 id="Listeners__u76D1_u542C_u5668"><a href="#Listeners__u76D1_u542C_u5668" class="headerlink" title="Listeners 监听器"></a>Listeners 监听器</h4>监听器提供不同的方式查看由采样器请求产生的结果。监听器以报表、树型结构、或简明的日志文件的形式分析结果。<h4 id="Timers__u5B9A_u65F6_u5668"><a href="#Timers__u5B9A_u65F6_u5668" class="headerlink" title="Timers 定时器"></a>Timers 定时器</h4>定时器来定义请求之间的等待时间。如果不指定，JMeter会一个请求完成后立即执行下一个请求，没有任何等待时间。<h4 id="Assertions__u65AD_u8A00"><a href="#Assertions__u65AD_u8A00" class="headerlink" title="Assertions 断言"></a>Assertions 断言</h4>断言通过验证采样器请求产生的响应，来验证测试计划的有效性。类似于单元测试断言，用来检测被测试应用程序的响应质量。<h4 id="Configuration_nodes__u914D_u7F6E_u8282_u70B9"><a href="#Configuration_nodes__u914D_u7F6E_u8282_u70B9" class="headerlink" title="Configuration nodes 配置节点"></a>Configuration nodes 配置节点</h4>配置节点可以将不同的参数传递给取样器请求。<h4 id="Pre_processors__u524D_u7F6E_u5904_u7406_u5668"><a href="#Pre_processors__u524D_u7F6E_u5904_u7406_u5668" class="headerlink" title="Pre processors 前置处理器"></a>Pre processors 前置处理器</h4>前置处理器在采样器执行前被触发的元素。<h4 id="Post_processors__u540E_u7F6E_u5904_u7406_u5668"><a href="#Post_processors__u540E_u7F6E_u5904_u7406_u5668" class="headerlink" title="Post processors 后置处理器"></a>Post processors 后置处理器</h4>后置处理器是取样器被执行后被触发执行的元素。</li>
</ul>
<h2 id="WorkBench"><a href="#WorkBench" class="headerlink" title="WorkBench"></a>WorkBench</h2><p><img src="/img/jmeter-2.png" alt="非测试元素"><br>WorkBench可以Add三个Non-test Elements:</p>
<ul>
<li>Http Mirror Server 镜像的服务器<br>其实就是一个代理服务器,它把所有接收到的请求原封不动地返回，这样就可以看到发出请求和响应的具体内容了。</li>
<li>Http(s) Test Script Recorder 脚本录制器<br>也是一个代理服务器,它会把所有接受的请求全部记录到Test Plan配置中,你在测试中可以使用这些录制的脚本。</li>
</ul>
<h2 id="u6D4B_u8BD5_u8BA1_u5212_u5143_u7D20_u6267_u884C_u987A_u5E8F"><a href="#u6D4B_u8BD5_u8BA1_u5212_u5143_u7D20_u6267_u884C_u987A_u5E8F" class="headerlink" title="测试计划元素执行顺序"></a>测试计划元素执行顺序</h2><ul>
<li>配置节点</li>
<li>前置处理器</li>
<li>定时器</li>
<li>取样器</li>
<li>后置处理器（只在有结果可用情况下执行）</li>
<li>断言（只在有结果可用情况下执行）</li>
<li>监听器（只在有结果可用情况下执行）</li>
</ul>
<h2 id="u6027_u80FD_u6307_u6807"><a href="#u6027_u80FD_u6307_u6807" class="headerlink" title="性能指标"></a>性能指标</h2><ul>
<li>Label:定义的HTTP请求名称</li>
<li>Samples:表示这次测试中一共发出了多少个请求</li>
<li>Average:访问页面的平均响应时间 </li>
<li>Min:访问页面的最小响应时间</li>
<li>Max:访问页面的最大响应时间</li>
<li>Error%:错误的请求的数量/请求的总数</li>
<li>Throughpu:每秒完成的请求数</li>
<li>KB/Sec:每秒从服务器端接收到的数据量</li>
<li>Median:50％的用户响应时间</li>
<li>90%Line:90％的用户响应时间</li>
<li>95%Line:95％的用户响应时间</li>
<li>99%Line:99％的用户响应时间<br>时间指标的单位都是毫秒。</li>
</ul>
<h2 id="u7B2C_u4E00_u4E2Aweb_u6027_u80FD_u6D4B_u8BD5"><a href="#u7B2C_u4E00_u4E2Aweb_u6027_u80FD_u6D4B_u8BD5" class="headerlink" title="第一个web性能测试"></a>第一个web性能测试</h2><p>我做了一个博客网站首页的性能测试，只设置ThreadGroup,Sampler,Listener三项就可以运行。</p>
<h4 id="ThreadGroup_u8BBE_u7F6E"><a href="#ThreadGroup_u8BBE_u7F6E" class="headerlink" title="ThreadGroup设置"></a>ThreadGroup设置</h4><p>一个性能测试请求负载是基于一个线程组完成的，jmeter中每个测试计划至少需要包含一个线程组。Test Plan右键菜单可新增ThreadGroup(add-&gt;Threads-&gt;ThreadGroup);<br><img src="/img/jmeter-3.png" alt="ThreadGroup"></p>
<ul>
<li>Number of Threads 线程数:虚拟用户数.一个虚拟用户占用一个进程或线程。</li>
<li>Ramp-up Period 准备时长:设置的虚拟用户数需要多长时间全部启动。</li>
<li>Loop Count 循环次数：每个线程发送请求的次数。</li>
</ul>
<h4 id="Sample_u8BBE_u7F6E"><a href="#Sample_u8BBE_u7F6E" class="headerlink" title="Sample设置"></a>Sample设置</h4><p>在ThreadGroup上右键菜单可新增HttpRequest（add-&gt;Sampler-&gt;HttpRequest).Sampler是与服务器进行交互的单元.一个Sampler通常进行三部分的工作：</p>
<ul>
<li>向服务器发送请求</li>
<li>记录服务器的响应数据</li>
<li>记录相应时间信息<br><img src="/img/jmeter-4.png" alt="HttpRequest"></li>
</ul>
<h4 id="Listener_u8BBE_u7F6E"><a href="#Listener_u8BBE_u7F6E" class="headerlink" title="Listener设置"></a>Listener设置</h4><p>脚本的主要部分设置完成后,需要通过某种方式获得性能测试中的测试结果。ThreadGroup上右键菜单可新增Listner（add-&gt;Listener-&gt;Aggregate Report).<br><img src="/img/jmeter-5.png" alt="HttpRequest"><br>我最关心的是我的博客响应时间，数据显示客户的平均响应时间为:337毫秒,99%的用户在1985毫秒内完成，也就不超2秒。最少用户响应时间为149毫秒，最大用户响应时间为5020毫秒</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近做性能优化工作，同时要给自己的工作给一个总结。需要自己弄性能测试及编写性能测试报告。在别人推荐下使用JMeter对项目进行性能测试。JMeter可以进行配置和执行负载测试、性能测试和压力测试的工具。了解一下几个概念:</p>
<ul>
<li>负载测试: 这类测试使系统或者应用程序在预先设计好的极端场景下测试运行。这类测试用来评估系统或者程序在极端条件下的行为。</li>
<li>性能测试: 这种测试被用来检测系统的性能表现，包括特定情况下，系统的响应能力和稳定性。</li>
<li>压力测试: 这类测试通过载入更多的外部资源，并使系统组件超越其所设定的能力范围,试图使系统挂掉.]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习8  Sentinel集群控制]]></title>
    <link href="http://binyanbin.github.io/2016/03/10/redis-8/"/>
    <id>http://binyanbin.github.io/2016/03/10/redis-8/</id>
    <published>2016-03-09T16:00:00.000Z</published>
    <updated>2016-03-10T15:53:20.146Z</updated>
    <content type="html"><![CDATA[<p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。<br><a id="more"></a></p>
<h2 id="Sentinel_u4EFB_u52A1"><a href="#Sentinel_u4EFB_u52A1" class="headerlink" title="Sentinel任务"></a>Sentinel任务</h2><ul>
<li>监控:Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒:当被监控的某个Redis服务器出现问题时,Sentinel 可以通过API向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移:当一个主服务器不能正常工作时,Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器, 并让失效主服务器的其他从服务器改为复制新的主服务器;当客户端试图连接失效的主服务器时,集群也会向客户端返回新主服务器的地址,使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<h2 id="u914D_u7F6ESentinel"><a href="#u914D_u7F6ESentinel" class="headerlink" title="配置Sentinel"></a>配置Sentinel</h2><p>下面是一个Sentinel的标准配置<br>port 26370<br>sentinel monitor master 127.0.0.1 6381 1<br>sentinel auth-pass master yanbin<br>sentinel down-after-milliseconds master 60000<br>sentinel parallel-syncs master 5<br>第一行配置指示Sentinel去监视一个名为master的主服务器,将这个主服务器判断为失效至少需要1个Sentinel同意。只要同意Sentinel的数量不达标,自动故障迁移就不会执行。<br>down-after-milliseconds 指定了Sentinel认为服务器已经断线所需的毫秒数。<br>parallel-syncs 执行故障转移时,最多可以有多少个从服务器同时对新的主服务器进行同步,数字越小,完成故障转移所需的时间就越长。<br>auth-pass 监视主服务器的密码。</p>
<h2 id="u8FD0_u884CSentinel"><a href="#u8FD0_u884CSentinel" class="headerlink" title="运行Sentinel"></a>运行Sentinel</h2><p>Sentinel配置在我这个windows 2.8这个版本中是没有的，我自建了一个sentinel.conf配置文件。然后使用命令行启动Sentinel：<br>redis-server  sentinel.conf –sentinel</p>
<h2 id="u6545_u969C_u6F14_u793A"><a href="#u6545_u969C_u6F14_u793A" class="headerlink" title="故障演示"></a>故障演示</h2><p>集群配置最少需要启动三个服务，我启动了4个服务分别是<br>127.0.0.1:26370 （redis sentinel 集群监控）<br>127.0.0.1:6379  （redis 主）<br>127.0.0.1:6380  （redis 从）<br>127.0.0.1:6381  （redis 从）<br>查看网络状态</p>
<pre><code class="bash">$ redis-cli -h 127.0.0.1 -p 26380 info Sentinel
Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
master0:name=master,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=1
</code></pre>
<p>接着我关闭一个服务</p>
<pre><code class="bash">redis-cli -h 127.0.0.1 -p 6379 shutdow
</code></pre>
<p>过了一会再次查看网络</p>
<pre><code class="bash">$ redis-cli -h 127.0.0.1 -p 26380 info Sentinel
<span class="comment">#Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
master0:name=master,status=ok,address=127.0.0.1:6381,slaves=1,sentinels=1
</code></pre>
<p>6381变成主redis,可以write操作。<br>再次启动6379</p>
<pre><code class="bash">$ redis-cli -h 127.0.0.1 -p 26380 info Sentinel
<span class="comment">#Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
master0:name=master,status=ok,address=127.0.0.1:6381,slaves=2,sentinels=1
</code></pre>
<p>6379已不是主redis，变成了从redis,不能再write操作，只能read.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习7 主从复制]]></title>
    <link href="http://binyanbin.github.io/2016/03/09/redis-7/"/>
    <id>http://binyanbin.github.io/2016/03/09/redis-7/</id>
    <published>2016-03-08T16:00:00.000Z</published>
    <updated>2016-03-09T14:52:32.154Z</updated>
    <content type="html"><![CDATA[<p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。<a id="more"></a>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2></li>
<li>把安装好的redis做master,然后copy一份当slave。然后修改slave配置<br>port 6379  修改为port 6380<br>slaveof 127.0.0.1 6379  (映射到主服务器上)</li>
<li>配置完成以后可以在二个服务中分别进行set和get操作来看效果,master可以get和set操作,slave上能get操作不能set，也就是说master可读可写，slave只能读。你在master上set数据，slave上可以查询得到。</li>
<li>在master和slave分别执行info命令，查看结果如下：<br><img src="/img/info1.png" alt="master"><br><img src="/img/info2.png" alt="slave"></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习6 持久化]]></title>
    <link href="http://binyanbin.github.io/2016/03/08/redis-6/"/>
    <id>http://binyanbin.github.io/2016/03/08/redis-6/</id>
    <published>2016-03-07T16:00:00.000Z</published>
    <updated>2016-03-07T14:17:00.704Z</updated>
    <content type="html"><![CDATA[<p>redis提供二种持久化方式:一种是RDB,另一种是AOF.<br>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br><a id="more"></a></p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><ul>
<li>rdb配置<br>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集:<br>save 60 1000</li>
<li>aof配置<br>appendonly yes  启用<br>appendfsync always 每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全<br>appendfsync everysec 每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。<br>appendfsync no 从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。<br>配置好，启动服务之后，在你程序的目录会出现二个文件，一个是dump.rdb,一个是appendonly.aof</li>
<li>RDB和AOF 之间的相互作用</li>
</ul>
<ol>
<li>当 Redis 启动时，如果RDB持久化和AOF持久化都被打开了，那么程序会优先使用 AOF 文件来恢复数据集，因为 AOF 文件所保存的数据通常是最完整的。</li>
<li>Redis为了防止两个后台(RDB和AOF)进程同时对磁盘进行大量的 I/O 操作。redis在RDB Save的过程中，不会执行 AOF RewriteAOF。反之,在AOF RewriteAOF执行的过程中，也不会执行RDB Save。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis提供二种持久化方式:一种是RDB,另一种是AOF.<br>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习5 lua脚本]]></title>
    <link href="http://binyanbin.github.io/2016/03/07/redis-5/"/>
    <id>http://binyanbin.github.io/2016/03/07/redis-5/</id>
    <published>2016-03-06T16:00:00.000Z</published>
    <updated>2016-03-07T14:19:29.124Z</updated>
    <content type="html"><![CDATA[<p>redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处:</p>
<ul>
<li>减少网络开销:批量执行redis命令。</li>
<li>原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。</li>
<li>复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。<a id="more"></a>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2></li>
<li>lua脚本<br>lua是一个很容易嵌入其它语言中使用的语言。很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。查看<a href="http://manual.luaer.cn/" target="_blank" rel="external">lua5.1在线中文用户手册</a>。</li>
<li>Eval<br>通过redis-cli客户端单独调用Lua脚本文件，格式如下:<br>redis-cli –eval myscript.lua [key …] arg [arg …]<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ </span><br><span class="line">限制一定时间内的调用次数 </span><br><span class="line">KEYS[1]:key </span><br><span class="line">ARGV[1]:存在时长</span><br><span class="line">ARGV[2]:调用次数</span><br><span class="line">]]</span></span><br><span class="line"><span class="keyword">local</span> times = redis.call(<span class="string">'incr'</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">'expire'</span>,KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>调用 redis-cli –eval d:\test.lua test:127.0.0.1 , 10 3</p>
<p>通过EVAL命令执行脚本，格式如下:<br>EVAL script numkeys key [key …] arg [arg …]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">eval</span> <span class="string">"local times = redis.call('incr',KEYS[1]);if times == 1 then redis.call('expire',KEYS[1], ARGV[1]);end;if times &gt; tonumber(ARGV[2]) then return 0;end;return 1"</span> <span class="number">1</span> <span class="built_in">test</span>:<span class="number">127.0</span>.<span class="number">0.1</span> , <span class="number">10</span> <span class="number">3</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get <span class="built_in">test</span>:<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<p>redis.call lua脚本通过redis.call调用redis命令。</p>
<p> 总结:我们可以通过Lua来实现很多功功能:用Lua来封装复杂了Redis操作的业务;计数，统计，分析，收集数据;实现业务操作事务控制等等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处:</p>
<ul>
<li>减少网络开销:批量执行redis命令。</li>
<li>原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。</li>
<li>复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习4 事务]]></title>
    <link href="http://binyanbin.github.io/2016/03/05/redis-4/"/>
    <id>http://binyanbin.github.io/2016/03/05/redis-4/</id>
    <published>2016-03-04T16:00:00.000Z</published>
    <updated>2016-03-05T17:14:58.831Z</updated>
    <content type="html"><![CDATA[<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<a id="more"></a>
<h2 id="u547D_u4EE4"><a href="#u547D_u4EE4" class="headerlink" title="命令"></a>命令</h2></li>
<li>multi 开启事务</li>
<li>discard 放弃事务</li>
<li>WATCH 事务执行条件</li>
<li>事务执行</li>
</ul>
<p>简单事务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<p>放弃事务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;discard</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p>
<p>事务条件:WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;watch yanbin</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;incr yanbin</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习3 数据类型]]></title>
    <link href="http://binyanbin.github.io/2016/03/03/redis-3/"/>
    <id>http://binyanbin.github.io/2016/03/03/redis-3/</id>
    <published>2016-03-02T16:00:00.000Z</published>
    <updated>2016-03-03T15:35:14.699Z</updated>
    <content type="html"><![CDATA[<p>redis数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hashes</li>
<li>Sets</li>
<li>Sorted sets<a id="more"></a>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2>存值取值:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;GET yanbin</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查询是否存在及删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;exists yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>设置失效时间及查询失效剩余时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire yanbin <span class="number">500</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;tll yanbin </span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">495</span></span><br></pre></td></tr></table></figure></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表是简单的字符串列表，可以排序插入顺序,可以在头部或列表的尾部Redis的列表添加元素。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;rpush yanbin a b c</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lpush yanbin <span class="number">1</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lrange <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lpop yanbin</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;rpop yanbin</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lrange <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;llen yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h2><p>哈希值是字符串字段和字符串值之间的映射，可以表示对象的数据类型。<br>其实实际应用中用json格式做数据保存，可以表示对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hmset user:<span class="number">1000</span> username antirez birthyear <span class="number">1977</span> verified <span class="number">1</span></span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hget user:<span class="number">1000</span> username</span><br><span class="line"><span class="string">"antirez"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hhgetall user:<span class="number">1000</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"username"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"antirez"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"birthyear"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"1977"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"verified"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>集合是一个无序的字符串合集,且不允许重复的成员。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;sadd yanbin <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;smembers yanbin</span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;scard yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Sorted_sets"><a href="#Sorted_sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h2><p>有序集合是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zadd yanbin <span class="number">1</span> a <span class="number">2</span> b <span class="number">3</span> c</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zrange yanbin <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zrange yanbin <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zcard yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hashes</li>
<li>Sets</li>
<li>Sorted sets]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习2 Pub/Sub]]></title>
    <link href="http://binyanbin.github.io/2016/03/02/redis-2/"/>
    <id>http://binyanbin.github.io/2016/03/02/redis-2/</id>
    <published>2016-03-01T16:00:00.000Z</published>
    <updated>2016-03-03T15:34:59.504Z</updated>
    <content type="html"><![CDATA[<p>Pub/Sub功能（means Publish,Subscribe）即发布及订阅功能.在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这让我想到了一种模式:观察者模式。定义了一种一对多的依赖关系，让多个观察者对象同时监听某一发布者（主题对象或目标对象），在发布者的状态发生变化时，会通知所有观察者对象。<br>常见的应用场景:构建实时消息系统，比如普通的即时聊天，群聊等功能。消息队列功能.<br><a id="more"></a></p>
<h2 id="Redis-cli"><a href="#Redis-cli" class="headerlink" title="Redis-cli"></a>Redis-cli</h2><ul>
<li>PSUBSCRIBE</li>
<li>PUBLISH</li>
<li>PUNSUBSCRIBE</li>
<li>SUBSCRIBE</li>
<li>UNSUBSCRIBE</li>
</ul>
<h3 id="u4E00_u4E2A_u5BA2_u6237_u7AEF_u8FDB_u884C_u8BA2_u9605_u64CD_u4F5C_28SUBSCRIBE_29_u3002"><a href="#u4E00_u4E2A_u5BA2_u6237_u7AEF_u8FDB_u884C_u8BA2_u9605_u64CD_u4F5C_28SUBSCRIBE_29_u3002" class="headerlink" title="一个客户端进行订阅操作(SUBSCRIBE)。"></a>一个客户端进行订阅操作(SUBSCRIBE)。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;subscribe first second</span><br><span class="line">Reading messages....</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"second"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>订阅first及second两个频道。</p>
<h3 id="u53E6_u4E00_u4E2A_u5BA2_u6237_u7AEF_u53D1_u5E03_u8BA2_u9605_u6D88_u606F_28PUBLISH_29_3A"><a href="#u53E6_u4E00_u4E2A_u5BA2_u6237_u7AEF_u53D1_u5E03_u8BA2_u9605_u6D88_u606F_28PUBLISH_29_3A" class="headerlink" title="另一个客户端发布订阅消息(PUBLISH):"></a>另一个客户端发布订阅消息(PUBLISH):</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;publish first <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>订阅客户端收到消息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;subscribe first second</span><br><span class="line">Reading messages....</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"second"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u9000_u8BA2_28UNSUBSCRIBE_29"><a href="#u9000_u8BA2_28UNSUBSCRIBE_29" class="headerlink" title="退订(UNSUBSCRIBE)"></a>退订(UNSUBSCRIBE)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;unsubsribe  first </span><br><span class="line">Reading messages....</span><br><span class="line"><span class="number">1</span>) <span class="string">"unsubsribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="u6309_u6A21_u5F0F_u8BA2_u9605_u548C_u9000_u8BA2_28PSUBSCRIBE_u548CPUNSUBSCRIBE_29"><a href="#u6309_u6A21_u5F0F_u8BA2_u9605_u548C_u9000_u8BA2_28PSUBSCRIBE_u548CPUNSUBSCRIBE_29" class="headerlink" title="按模式订阅和退订(PSUBSCRIBE和PUNSUBSCRIBE)"></a>按模式订阅和退订(PSUBSCRIBE和PUNSUBSCRIBE)</h3><p>每个模式以 <em> 作为匹配符，比如 it</em> 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)。 news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Pub/Sub功能（means Publish,Subscribe）即发布及订阅功能.在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这让我想到了一种模式:观察者模式。定义了一种一对多的依赖关系，让多个观察者对象同时监听某一发布者（主题对象或目标对象），在发布者的状态发生变化时，会通知所有观察者对象。<br>常见的应用场景:构建实时消息系统，比如普通的即时聊天，群聊等功能。消息队列功能.<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习1 环境及配置]]></title>
    <link href="http://binyanbin.github.io/2016/02/28/redis-1/"/>
    <id>http://binyanbin.github.io/2016/02/28/redis-1/</id>
    <published>2016-02-27T16:00:00.000Z</published>
    <updated>2016-03-09T14:51:42.420Z</updated>
    <content type="html"><![CDATA[<p>最近工作需要使用redis，现在只能边学习边总结。Redis的介绍就不说了，网上一搜一大把。</p>
<h2 id="u73AF_u5883_u642D_u5EFA"><a href="#u73AF_u5883_u642D_u5EFA" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官方不提供windows版redis，<a href="https://github.com/MSOpenTech" target="_blank" rel="external">微软开源技术的github</a>上有提供，可以<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="external">下载</a>。下载解决之后，我们就开始可以搭建开发环境。<br><a id="more"></a></p>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><ul>
<li>maxheap<br>这个是一个强限制，maxheap的大小包括文件存储大小及内存存储大小。如果超过这个限制，服务就会结束。</li>
<li>maxmemory<br>maxheap必需要比maxmemory大，一般设置为maxmemory的1.5倍。</li>
<li>文件系统大小<br>redis官方提供的公式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(size of physical memory) + (2 * size of maxheap)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果你有一台机器内存为8G,maxheap设置为8G，那么你至少要有这么多空闲硬盘空间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(8GB) + (2 * 8GB) = 24GB</span><br></pre></td></tr></table></figure></p>
<ul>
<li>maxmemory-policy<br>如果运行中达到了maxmemory，redis将根据这个设置清除一些存储数据。</li>
<li>requirepass<br>设置服务密码。</li>
<li>heapdir<br>内存映射文件路径</li>
<li>timeout<br>连接超时时间</li>
</ul>
<h3 id="u8FD0_u884C"><a href="#u8FD0_u884C" class="headerlink" title="运行"></a>运行</h3><p>启动服务<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.windows.conf</span><br></pre></td></tr></table></figure></p>
<p>启动客户端<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -p <span class="number">6379</span> -a password</span><br></pre></td></tr></table></figure></p>
<h3 id="u57FA_u672C_u547D_u4EE4"><a href="#u57FA_u672C_u547D_u4EE4" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> key value </span><br><span class="line">get key</span><br><span class="line"><span class="winutils">del</span> key</span><br><span class="line">exists key</span><br><span class="line">expire key <span class="number">100</span></span><br><span class="line">keys *</span><br><span class="line">db size</span><br><span class="line">ttl key</span><br><span class="line">info</span><br><span class="line">flushdb </span><br><span class="line"><span class="winutils">ping</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近工作需要使用redis，现在只能边学习边总结。Redis的介绍就不说了，网上一搜一大把。</p>
<h2 id="u73AF_u5883_u642D_u5EFA"><a href="#u73AF_u5883_u642D_u5EFA" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官方不提供windows版redis，<a href="https://github.com/MSOpenTech">微软开源技术的github</a>上有提供，可以<a href="https://github.com/MSOpenTech/redis/releases">下载</a>。下载解决之后，我们就开始可以搭建开发环境。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[并发情况下锁的使用]]></title>
    <link href="http://binyanbin.github.io/2016/02/26/lock/"/>
    <id>http://binyanbin.github.io/2016/02/26/lock/</id>
    <published>2016-02-25T16:00:00.000Z</published>
    <updated>2016-02-27T16:12:34.744Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://binyanbin.github.io/2016/02/18/interview-hishop/">电商面试题</a>中，我使用了锁来控制并发时的缓存使用。为什么要加锁，因为在并发环境下，一个线程正在修改缓存，另一个线程在读缓存时，缓存数据很可能会被破坏;另外，使用锁可以控制超卖现像。下面我介绍常用的二种锁：读写锁和互斥锁。<br><a id="more"></a></p>
<h1 id="u8BFB_u5199_u9501"><a href="#u8BFB_u5199_u9501" class="headerlink" title="读写锁"></a>读写锁</h1><p>缓存一般使用的情况应该是:</p>
<ul>
<li>只能由一个线程写，但可以多个线程读。</li>
<li>在读操作时，不能同时让其它线程写，在写操作时，不能同时读。</li>
</ul>
<p>实现以上两种情况的锁称读写锁，读写锁有两种模式。</p>
<ul>
<li>读模式:可以有多个线程同时占有。</li>
<li>写模式:一次只有一个线程可以占有。</li>
</ul>
<h1 id="u4E92_u65A5_u9501"><a href="#u4E92_u65A5_u9501" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>在我面试题的代码中所有操作使用的是互斥锁，即保证lock上的代码同一时刻只被一个线程操作。这么做可以保证在任意时刻只有单个线程访问缓存，做到线程安全，但是这种方式效率并不高。原因如下:</p>
<ul>
<li>降低读的并发性，降低了系统使用效率。</li>
<li>像限时抢购、秒杀这种高并发场景，应该要支持对不同的抢购商品并发下单，提高下单效率。</li>
</ul>
<h1 id="u9650_u65F6_u62A2_u8D2D_u3001_u79D2_u6740_u5E76_u53D1_u573A_u666F_u7684_u5E94_u7528"><a href="#u9650_u65F6_u62A2_u8D2D_u3001_u79D2_u6740_u5E76_u53D1_u573A_u666F_u7684_u5E94_u7528" class="headerlink" title="限时抢购、秒杀并发场景的应用"></a>限时抢购、秒杀并发场景的应用</h1><p>1.应为每个商品订单缓存建一个读写锁。<br>2.在对商品下单时，应该对该商品加上写模式锁，保证该商品同一时刻只有一个用户下单，不会引起商品超卖。<br>3.获取订单缓存数据时，应为该商品加上读模式锁，保证其它线程也可以读到缓存订单数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://binyanbin.github.io/2016/02/18/interview-hishop/">电商面试题</a>中，我使用了锁来控制并发时的缓存使用。为什么要加锁，因为在并发环境下，一个线程正在修改缓存，另一个线程在读缓存时，缓存数据很可能会被破坏;另外，使用锁可以控制超卖现像。下面我介绍常用的二种锁：读写锁和互斥锁。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一家公司的8年技术总结]]></title>
    <link href="http://binyanbin.github.io/2016/02/23/8year-review/"/>
    <id>http://binyanbin.github.io/2016/02/23/8year-review/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-02-23T17:10:37.294Z</updated>
    <content type="html"><![CDATA[<p>今天离职手续终于办完了，顺便回顾一下公司这几年研发技术的发展。</p>
<h2 id="asp-net_webform"><a href="#asp-net_webform" class="headerlink" title="asp.net webform"></a>asp.net webform</h2><p>我刚进公司那会，公司的所有项目基本上都是按照微软的petshop来做的，页面采用webform。当时还是觉得很牛B。当时也不知道什么前后端，所有代码全由后端开发人员包办，从数据库到界面，美工把css写好，开发人员只要在控件中指定css中的class,就可以实现效果，这种方式上手简单，开发快速。缺点就不叙述了，总结一点，只合适做特定项目。<br><img src="/img/1.png" alt="webform"></p>
<h2 id="asp-net_mvc"><a href="#asp-net_mvc" class="headerlink" title="asp.net mvc"></a>asp.net mvc</h2><p>大概在2009年左右，我去参加微软技术大会，当时微软推asp.net mvc。回来之后建议公司采用了asp.net mvc方式开发项目，在此终于有一点前后端的概念了，当然对开发人员要求也高了一些，再没有无所不能的控件使用了，但是更灵活。这时候需要美工做好静态页面，静态页面中还需要包括交互效果，开发人员按照静态页面用服务端模板语言生成。但是09年那次的使用并不成功，1.开发人员要求高，2.当年的版本并不成熟。<br><img src="/img/2.png" alt="mvc"></p>
<h2 id="asp-net_webapi_+__u524D_u7AEFmvc_u7684_u624B_u673A_u5F00_u53D1_u6A21_u5F0F"><a href="#asp-net_webapi_+__u524D_u7AEFmvc_u7684_u624B_u673A_u5F00_u53D1_u6A21_u5F0F" class="headerlink" title="asp.net webapi + 前端mvc的手机开发模式"></a>asp.net webapi + 前端mvc的手机开发模式</h2><p>从12年公司开始做手机,由于原生开发成本太高，最后采用hybrid开发模式，最终使用开源项目cordova来开发手机app，前后端彻底分开，前端的静态页面直接放到手机中，通过ajax调用webapi中取数据，再把数据绑到前端模板上进行界面渲染。这是美工只需要做图或静态界面，不需要实现界面交互，界面交互、服务端交互、手机交互全由前端开发完成，前端开发还需要定义webapi的接口，后端开发只管实现webapi接口，能满足前端所需要的数据要求。这种以前端为主导的开发模式，对前端开发人员要求更高，但是为公司培养了一堆优秀的前端开发人员。<br><img src="/img/3.png" alt="webapi"></p>
<h2 id="u5927_u524D_u7AEF_28_u5168_u6808_29_u5F00_u53D1"><a href="#u5927_u524D_u7AEF_28_u5168_u6808_29_u5F00_u53D1" class="headerlink" title="大前端(全栈)开发"></a>大前端(全栈)开发</h2><p>本来想使用此模式尝试做web开发，由前端完成从界面到路由，从登陆到权限，以及session,cookie等进行完全控制，后端专注于业务及数据，按照做手机开发模式那样，给前端开发更大的空间。但最终没能尝试就已离职。<br><img src="/img/4.png" alt="全栈开发"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天离职手续终于办完了，顺便回顾一下公司这几年研发技术的发展。</p>
<h2 id="asp-net_webform"><a href="#asp-net_webform" class="headerlink" title="asp.net webform"></a>as]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript的面向对象编程]]></title>
    <link href="http://binyanbin.github.io/2016/02/21/javascript-base-3/"/>
    <id>http://binyanbin.github.io/2016/02/21/javascript-base-3/</id>
    <published>2016-02-20T16:00:00.000Z</published>
    <updated>2016-02-27T16:33:03.403Z</updated>
    <content type="html"><![CDATA[<p>Javascript里的所有东西都是对象，可是它又不并像Java,C#。不是严格意义上的OOP语言。但是它可以实现OOP的效果。但在之前你需要了解哪些关键的知识点?</p>
<h2 id="u5173_u952E_u77E5_u8BC6_u70B9"><a href="#u5173_u952E_u77E5_u8BC6_u70B9" class="headerlink" title="关键知识点"></a>关键知识点</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>我们看下面这个使用this的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"yanbin"</span>,</span><br><span class="line">    showName :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> other =&#123;</span><br><span class="line">    name:<span class="string">"changsha"</span>,</span><br><span class="line">    showName:obj.showName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>obj.showName()提示的是yanbin,obj.showName()提示的是changsha，this是指执行时当前的对象。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行时函数不属于任何对象时,this表示window。(使用var定义的对象也属于window)</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>在Javascript中,new一个函数它做了以下3件事:</p>
<ul>
<li>创建新对象。</li>
<li>拷贝prototype到新对象。</li>
<li>设置构造函数</li>
<li>执行函数返回给新对象。<br>请看下面这个示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'yanbin'</span>;</span><br><span class="line">    <span class="keyword">this</span>.showcity =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	alert(<span class="string">'changsha'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span>  model =<span class="keyword">new</span> func();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过代码还原new的步骤<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newobj = &#123;&#125;;</span><br><span class="line">newobj.__proto__ = func.prototype;</span><br><span class="line">func.prototype.constructor = func;</span><br><span class="line">p.apply(newobj)</span><br><span class="line"><span class="keyword">var</span> model = newobj;</span><br></pre></td></tr></table></figure></p>
<p>这段代码我们需要搞清楚二个属性:</p>
<ul>
<li>prototype:在定义一个新函数，都会给函数创建一个prototype属性，也就是原型对象，把它看成普通对象也行了，但它可以影响这个函数实例的<strong>protype</strong>.</li>
<li>__protype__:是函数实例的原型对象指针，每次new一个函数的时候都会给实例生成一个指针newobj.__proto__=func.protype。当函数的原型对象改变时，那么实例也会发生改变，因为__proto__只是指针，所以它也不能修改，只能对应的原型方法或属性访问它。<br>弄清楚了这些我们就可以开始OPP实践了。</li>
</ul>
<h2 id="u5C01_u88C5_u793A_u4F8B"><a href="#u5C01_u88C5_u793A_u4F8B" class="headerlink" title="封装示例"></a>封装示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name,sex,s</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name =name;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayname</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        alert(<span class="string">"my name is "</span>+ name +<span class="string">", i'm a "</span>+sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.say =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        sayname();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> secret = s;</span><br><span class="line">    <span class="keyword">this</span>.getsecret = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setsecret = <span class="function"><span class="keyword">function</span>(<span class="params">ss</span>)</span>&#123;</span><br><span class="line">        secret = ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> model =<span class="keyword">new</span> Person(<span class="string">'yanbin'</span>,<span class="string">'man'</span>,<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure>
<p>name,sex是公开属性,sayname是一个私有方法，say是一个公共方法。secret是一个私有属性,对它的赋值和取值则是通过getsecret和setsecret这二个方法。</p>
<h2 id="u7EE7_u627F_u793A_u4F8B"><a href="#u7EE7_u627F_u793A_u4F8B" class="headerlink" title="继承示例"></a>继承示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">n</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        alert(<span class="string">"my name is:"</span>+ <span class="keyword">this</span>.realname);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">this</span>.realname = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.prototype = &#123;</span><br><span class="line">    realname : <span class="keyword">this</span>.realname,</span><br><span class="line">    say : <span class="keyword">this</span>.say</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">sex</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.getsex = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype = <span class="keyword">new</span> Man(<span class="string">'yanbin'</span>);</span><br><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> Employee(<span class="string">"female"</span>);</span><br></pre></td></tr></table></figure>
<p>Employee继承man的say方法和realname属性，Emplayee有一个私有属性sex和一个getsex方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Javascript里的所有东西都是对象，可是它又不并像Java,C#。不是严格意义上的OOP语言。但是它可以实现OOP的效果。但在之前你需要了解哪些关键的知识点?</p>
<h2 id="u5173_u952E_u77E5_u8BC6_u70B9"><a href="#u5173_u952E_u77E5_u8BC6_u70B9" class="headerlink" title="关键知识点"></a>关键知识点</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>我们看下面这个使用this的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"yanbin"</span>,</span><br><span class="line">    showName :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> other =&#123;</span><br><span class="line">    name:<span class="string">"changsha"</span>,</span><br><span class="line">    showName:obj.showName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>obj.showName()提示的是yanbin,obj.showName()提示的是changsha，this是指执行时当前的对象。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript的匿名函数]]></title>
    <link href="http://binyanbin.github.io/2016/02/20/javascript-base-2/"/>
    <id>http://binyanbin.github.io/2016/02/20/javascript-base-2/</id>
    <published>2016-02-19T16:00:00.000Z</published>
    <updated>2016-02-22T02:16:39.892Z</updated>
    <content type="html"><![CDATA[<p>匿名函数在javascript中非常常见且实用，它最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。javascript的框架这种用法随处可见。下面看二个例子，如何定义匿名函数。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">       alert(t);</span><br><span class="line">   &#125;;</span><br><span class="line">f(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure></p>
<p>“=”右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量f。通过f再调用这个匿名函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">	alert(t)</span><br><span class="line">   &#125;)(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。<br>这就是匿名函数常用的使用方式，通常用得最多的是第二种。</p>
<p>前端人员一般为了避免声明了一些全局变量而污染，把代码放在一个“沙箱执行”，然后在暴露出命名空间（可以为API，函数，对象）,如Jquery:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure>
<p>再如我想建一个自己的框架叫yb:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> yb = &#123;</span><br><span class="line">		add:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="string">"add"</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		sub:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="string">"sub"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">window</span>.yb = yb;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>你的方法add和sub只能通过全局对象yb访问，这个是函数闭包规则决定的。如不能理解闭包请参见<a href="http://binyanbin.github.io/2016/01/03/javascript-base-1/">函数的闭包</a>;</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>匿名函数在javascript中非常常见且实用，它最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。javascript的框架这种用法随处可见。下面看二个例子，如何定义匿名函数。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[电商面试题]]></title>
    <link href="http://binyanbin.github.io/2016/02/18/interview-hishop/"/>
    <id>http://binyanbin.github.io/2016/02/18/interview-hishop/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-03-23T14:20:24.876Z</updated>
    <content type="html"><![CDATA[<p>15年年底去一家电商服务公司面试，其中有一道题目是如何解决电商站点商品秒杀的相关问题。<a href="https://github.com/hishopdc/dc2015" target="_blank" rel="external">面试题目可以参见</a>。固定的数据库结构下实现三个接口，查看、下单、付款。<br><a id="more"></a></p>
<h2 id="u4E3B_u8981_u95EE_u9898_3A_u9AD8_u5E76_u53D1_u67E5_u8BE2_u53CA_u66F4_u65B0_u6570_u636E_u5E93"><a href="#u4E3B_u8981_u95EE_u9898_3A_u9AD8_u5E76_u53D1_u67E5_u8BE2_u53CA_u66F4_u65B0_u6570_u636E_u5E93" class="headerlink" title="主要问题:高并发查询及更新数据库"></a>主要问题:高并发查询及更新数据库</h2><p>解决的方案其实比较其实并不复杂，也很常规。无非就是用缓存队列实现批量更新数据库。把下单的数据放入队列中，然后批量更新到数据库中去。说起来比较简单，实践中还是踩了一些坑。</p>
<h3 id="u4E3B_u8981_u5B9E_u73B0_u903B_u8F91"><a href="#u4E3B_u8981_u5B9E_u73B0_u903B_u8F91" class="headerlink" title="主要实现逻辑"></a>主要实现逻辑</h3><p>订单处理类<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 订单缓存队列处理类</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderCacheQuene</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 订单队列缓存</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Order&gt; _orders;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 数据库操作接口</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IPromotion _service;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 锁</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> _locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 队列处理线程</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread _thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 订单队列启动</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        _thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(OrderDispose));</span><br><span class="line">        _thread.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 缓存结束</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span> (_locker)</span><br><span class="line">        &#123;</span><br><span class="line">            _thread.Abort();</span><br><span class="line">            _service.OrderTrans(_orders);</span><br><span class="line">            _orders.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 下单</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">OrderBuy</span>(<span class="params">Order o</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span> (_locker)</span><br><span class="line">        &#123;</span><br><span class="line">            _orders.Add(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o.OrderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 支付</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">OrderPay</span>(<span class="params">RequestPay o, DateTime? paytime</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span> (_locker)</span><br><span class="line">        &#123;</span><br><span class="line">        	Order order = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> index = _orders.FindIndex(t =&gt; t.OrderId == o.order_id &amp;&amp; t.UserId == o.uid);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>)<span class="comment"><span class="xmlDocTag">///</span>已存在缓存中</span></span><br><span class="line">            &#123;</span><br><span class="line">                _orders[index].PayTime = paytime;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;            	</span><br><span class="line">            order = _service.GetOrder(o.order_id);</span><br><span class="line">            <span class="keyword">if</span> (order == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span><span class="comment"><span class="xmlDocTag">///</span>已存在数据库中</span></span><br><span class="line">            &#123;</span><br><span class="line">                order.PayTime = paytime;</span><br><span class="line">                <span class="keyword">lock</span> (_locker)</span><br><span class="line">                &#123;</span><br><span class="line">                    _orders.Add(order);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 判断队列是否已满</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isFull</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _orders.Count &gt;= Constant.QueueMaxCount ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 订单队列处理事件</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OrderDispose</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//DateTime starttime = DateTime.Now;</span></span><br><span class="line">            <span class="keyword">lock</span> (_locker)</span><br><span class="line">            &#123;</span><br><span class="line">               List&lt;Order&gt; orders =  _orders.Take(Constant.MaxOrderDispose).ToList();</span><br><span class="line">                _service.OrderTrans(orders.ToList());<span class="comment">//调用数据库接口处理订单</span></span><br><span class="line">                <span class="keyword">foreach</span> (Order o <span class="keyword">in</span> orders)</span><br><span class="line">                    _orders.Remove(o);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.Sleep(Constant.QueueDisposeTimeSpan);<span class="comment">//每次处理完成休眠</span></span><br><span class="line">            <span class="comment">//DateTime endtime = DateTime.Now;</span></span><br><span class="line">            <span class="comment">//System.Diagnostics.Debug.WriteLine("Yanbin TimeSpan:"+endtime.Subtract(starttime).Milliseconds);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存我直接使用的静态对像，效果是一样的。批量提交的方法是 _service.OrderTrans，在这里就不列出来，但是一些数据库操作。</p>
<p>订单队列启动与结束</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WebApiApplication : System.Web.HttpApplication</span><br><span class="line">&#123;</span><br><span class="line">    protected void Application_Start()</span><br><span class="line">    &#123;</span><br><span class="line">        //订单队列初始化</span><br><span class="line">        OrderCacheQuene.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void Application_End()</span><br><span class="line">    &#123;</span><br><span class="line">        //结束处理</span><br><span class="line">        OrderCacheQuene.End();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u57511_3A_u8D85_u5356"><a href="#u57511_3A_u8D85_u5356" class="headerlink" title="坑1:超卖"></a>坑1:超卖</h3><p>程序实现以后，我写了一个测试程序去跑它，跑到200线程时超卖了，思来想去之后发现是判断的问题，开始下单时的判断条件没有放到订单队列程序里面。因为并发大，所以有一些客户端请求下单的时候,程序判断是满足下单条件,但是还有一些客户端的请求正在响应，把订单加入缓存了，造成判断不一致，最终引起超卖。所以下单的条件判断需要加到锁里面，虽然对性能上有一些损耗，但是可以保证不会超卖。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 下单</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">OrderBuy</span>(<span class="params">Order o</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lock</span> (_locker)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span> (队列已满，已卖空，已下单等条件)</span><br><span class="line">     	<span class="keyword">return</span> <span class="keyword">null</span>;            	</span><br><span class="line">        _orders.Add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.OrderId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u57512_3A_u6548_u7387_u5751"><a href="#u57512_3A_u6548_u7387_u5751" class="headerlink" title="坑2:效率坑"></a>坑2:效率坑</h3><p>做web接口，在.net的系统中当然用webapi,更种好处用过都知道，没想到在高并发的条件下效率不如handler。以下这些数据是在我这台旧的笔记本上测试出来的。</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程调用接口数</th>
<th>处理方式</th>
<th>说明</th>
<th>产生订单数</th>
<th>接口方式</th>
<th>完成时间(秒)</th>
<th>完成时间(分钟)</th>
<th>处理请求总数</th>
<th>平均每秒处理请求</th>
</tr>
</thead>
<tbody>
<tr>
<td>2000</td>
<td>100</td>
<td>只查询</td>
<td>2000人同时查100种商品</td>
<td>0</td>
<td>handler</td>
<td>650.5</td>
<td>10.84</td>
<td>199706</td>
<td>307.004</td>
</tr>
<tr>
<td>2000</td>
<td>100</td>
<td>只查询</td>
<td>2000人同时查100种商品</td>
<td>0</td>
<td>api</td>
<td>1180.8</td>
<td>19.68</td>
<td>199747</td>
<td>169.162</td>
</tr>
<tr>
<td>1000</td>
<td>50</td>
<td>只查询</td>
<td>1000人同时查50种商品</td>
<td>0</td>
<td>handler</td>
<td>86.3</td>
<td>1.44</td>
<td>49932</td>
<td>578.586</td>
</tr>
<tr>
<td>1000</td>
<td>50</td>
<td>只查询</td>
<td>1000人同时查50种商品</td>
<td>0</td>
<td>api</td>
<td>103.9</td>
<td>1.73</td>
<td>49948</td>
<td>480.731</td>
</tr>
<tr>
<td>2000</td>
<td>10</td>
<td>抢购</td>
<td>2000人抢100个订单</td>
<td>100</td>
<td>handler</td>
<td>81.9</td>
<td>1.37</td>
<td>40430</td>
<td>493.651</td>
</tr>
<tr>
<td>2000</td>
<td>10</td>
<td>抢购</td>
<td>2000人抢100个订单</td>
<td>100</td>
<td>api</td>
<td>79.7</td>
<td>1.33</td>
<td>28738</td>
<td>360.577</td>
</tr>
<tr>
<td>2000</td>
<td>50</td>
<td>并发购买</td>
<td>50个人同时买2000种不同商品</td>
<td>100000</td>
<td>Handler</td>
<td>3467</td>
<td>57.78299471</td>
<td>86.378</td>
</tr>
<tr>
<td>2000</td>
<td>50</td>
<td>并发购买</td>
<td>50个人同时买2000种不同商品</td>
<td>100000</td>
<td>api</td>
<td>3638</td>
<td>60.63</td>
<td>299375</td>
<td>82.291</td>
</tr>
</tbody>
</table>
<p>从上图可以看出，在高并发情况下webapi的性能确实不行。</p>
<h3 id="u5F00_u53D1_u603B_u7ED3"><a href="#u5F00_u53D1_u603B_u7ED3" class="headerlink" title="开发总结"></a>开发总结</h3><ul>
<li>锁在高并发的情况下的使用，如何满足业务要求。</li>
<li>缓存的使用，缓存与数据库之间的数据如何保持一致。</li>
<li>对于大型电商网站，缓存队列需要设置上限，不然会引起内存问题，不过在这里不是这道题目的重点。</li>
</ul>
<p><a href="https://github.com/binyanbin/interview/" target="_blank" rel="external">源码下载</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>15年年底去一家电商服务公司面试，其中有一道题目是如何解决电商站点商品秒杀的相关问题。<a href="https://github.com/hishopdc/dc2015">面试题目可以参见</a>。固定的数据库结构下实现三个接口，查看、下单、付款。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript的闭包]]></title>
    <link href="http://binyanbin.github.io/2016/01/03/javascript-base-1/"/>
    <id>http://binyanbin.github.io/2016/01/03/javascript-base-1/</id>
    <published>2016-01-02T16:00:00.000Z</published>
    <updated>2016-02-21T14:51:30.124Z</updated>
    <content type="html"><![CDATA[<p>闭包是Javascript的一个重点的概念，在开发过程中用得非常多，但是在了解闭包之前我们需要了解全局与局部的概念，下面来看这个例子。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">myfun</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">   	<span class="keyword">var</span> my = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">infun</span>(<span class="params"></span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="keyword">in</span> = <span class="number">2</span>;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">innerfun</span>(<span class="params"></span>)</span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> inner = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">infun2</span>(<span class="params"></span>)</span><br><span class="line">   ｛</span><br><span class="line">	｝</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title">function</span> <span class="title">myfun2</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个三层嵌套的函数。我对局部的了解是指函数的内部，局部对像就是指函数内部的变量及函数。全局对象就是没有定义在任何函数内的变量和函数。全局对象是window的子对象。</p>
<p>在上面的这个程序中，全局对象有:<br><em>global变量
</em>myfun函数<br>*myfun2函数</p>
<p>myfun的内部对像有:<br><em>my变量
</em>infun函数<br>*infun2函数</p>
<p>infun的内部对像有:<br><em>in变量
</em>innerfun函数<br>以此类推。</p>
<p>了解了局部与全局后，闭包就容易了解,它是指内层函数可以使用外层函数局部对象，外层函数不能使用内层函数的局部对象，这种规则就叫函数的闭包。<br>从上面这个例子，我们就清楚在innerfun函数中，可以访问当前所有对像，因为它是最内层函数。而在infun函数中除了innerfun函数和它的内部变量inner不能访问外，其它的也都可以访问。<br>大家都可以访问全局对象，因为它在最外层。这就是为什么很多js库总是建一个对象放到window下做全局对象，你只要引用就可以访问到它。</p>
<p>补充:没有使用var进行定义的变量也是全局对象。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfun</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> part =<span class="string">"part variable"</span>;</span><br><span class="line">    global  =<span class="string">"global variable"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>闭包是Javascript的一个重点的概念，在开发过程中用得非常多，但是在了解闭包之前我们需要了解全局与局部的概念，下面来看这个例子。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何用hexo上做个blog站点]]></title>
    <link href="http://binyanbin.github.io/2016/01/02/hello-world/"/>
    <id>http://binyanbin.github.io/2016/01/02/hello-world/</id>
    <published>2016-01-01T16:00:00.000Z</published>
    <updated>2016-02-20T02:09:40.357Z</updated>
    <content type="html"><![CDATA[<p>2016年起，我要写博客了!各种博客网站都不合我意，最后用hexo+github搭了一个博客网站，全免费，还可以把开源项目放在里面，关键完全可以自己控制，入门虽然有一点难度，但是熟习以后使用起来其实相当简单. <a href="http://hexo.io/docs/" target="_blank" rel="external">了解关于hexo更多信息</a>. <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">hexo常见问题</a> 你也可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>上提问.</p>
<h2 id="u5F00_u542F"><a href="#u5F00_u542F" class="headerlink" title="开启"></a>开启</h2><h3 id="u521B_u5EFA_u65B0blog"><a href="#u521B_u5EFA_u65B0blog" class="headerlink" title="创建新blog"></a>创建新blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a><br><a id="more"></a></p>
<h3 id="u542F_u52A8web_u670D_u52A1_u5668"><a href="#u542F_u52A8web_u670D_u52A1_u5668" class="headerlink" title="启动web服务器"></a>启动web服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="u751F_u6210_u9759_u6001_u6587_u4EF6"><a href="#u751F_u6210_u9759_u6001_u6587_u4EF6" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="u53D1_u5E03_u7AD9_u70B9"><a href="#u53D1_u5E03_u7AD9_u70B9" class="headerlink" title="发布站点"></a>发布站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>一切看上去就是那么简单。但是用hexo做博客网站，你还需要懂一点nodejs,markdown语法，如果你想把网站放到github上，你还需要了解点git shell。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2016年起，我要写博客了!各种博客网站都不合我意，最后用hexo+github搭了一个博客网站，全免费，还可以把开源项目放在里面，关键完全可以自己控制，入门虽然有一点难度，但是熟习以后使用起来其实相当简单. <a href="http://hexo.io/docs/">了解关于hexo更多信息</a>. <a href="http://hexo.io/docs/troubleshooting.html">hexo常见问题</a> 你也可以在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上提问.</p>
<h2 id="u5F00_u542F"><a href="#u5F00_u542F" class="headerlink" title="开启"></a>开启</h2><h3 id="u521B_u5EFA_u65B0blog"><a href="#u521B_u5EFA_u65B0blog" class="headerlink" title="创建新blog"></a>创建新blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html">Writing</a><br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于博客]]></title>
    <link href="http://binyanbin.github.io/2015/12/20/self-introduce/"/>
    <id>http://binyanbin.github.io/2015/12/20/self-introduce/</id>
    <published>2015-12-19T16:00:00.000Z</published>
    <updated>2016-03-22T13:16:54.991Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2"><a href="#u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2" class="headerlink" title="为什么建这个博客"></a>为什么建这个博客</h2><p>其实很早的时候我写过博客，是在第三方网站上，当时的博客网站系统排个版都让我很头疼，可能也是因为不太熟习怎么用，最后坚持了一小会就放弃了。今年准备换工作，所以15年底去了几家公司面试，面对一堆的笔试，面试，机试各种试，感觉很累。想想原因，还是用人单位不了解你，就算你一份简历吹上天，也很难让用人单位相信你，你又没有人推荐。为了让我这把老骨头不在那么折腾,今年我要写博客，要参与开源项目。<br><a id="more"></a></p>
<h2 id="u5173_u4E8E_u6211"><a href="#u5173_u4E8E_u6211" class="headerlink" title="关于我"></a>关于我</h2><table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:left">严彬</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">年龄</td>
<td style="text-align:left">34</td>
</tr>
<tr>
<td style="text-align:left">居住地</td>
<td style="text-align:left">长沙</td>
</tr>
</tbody>
</table>
<p>在IT行业差不多干了12年，最近的一家公司呆了8年，做了5年技术管理之后，16年初离职之后，还是想当一名职业程序员，自称为码工，码工者以代码为工具而不限于某种代码。现在在一家电商服务公司担任开发。</p>
<h2 id="u670D_u52A1"><a href="#u670D_u52A1" class="headerlink" title="服务"></a>服务</h2><ul>
<li>承接长沙当地企业技术培训及咨询工作。</li>
</ul>
<p>QQ:8999482 邮箱:yanbin.yb@hotmail.com 欢迎骚扰。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2"><a href="#u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2" class="headerlink" title="为什么建这个博客"></a>为什么建这个博客</h2><p>其实很早的时候我写过博客，是在第三方网站上，当时的博客网站系统排个版都让我很头疼，可能也是因为不太熟习怎么用，最后坚持了一小会就放弃了。今年准备换工作，所以15年底去了几家公司面试，面对一堆的笔试，面试，机试各种试，感觉很累。想想原因，还是用人单位不了解你，就算你一份简历吹上天，也很难让用人单位相信你，你又没有人推荐。为了让我这把老骨头不在那么折腾,今年我要写博客，要参与开源项目。<br>]]>
    
    </summary>
    
  </entry>
  
</feed>
