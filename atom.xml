<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[码工严彬 coding不仅仅是工作]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://binyanbin.github.io/"/>
  <updated>2016-05-08T15:14:56.859Z</updated>
  <id>http://binyanbin.github.io/</id>
  
  <author>
    <name><![CDATA[严彬]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[golang是不是后端开发神器]]></title>
    <link href="http://binyanbin.github.io/2016/05/08/go-1/"/>
    <id>http://binyanbin.github.io/2016/05/08/go-1/</id>
    <published>2016-05-07T16:00:00.000Z</published>
    <updated>2016-05-08T15:14:56.859Z</updated>
    <content type="html"><![CDATA[<p>周末有人介绍golang很合适后端开发，随即把之前C实现的静态资源下载功能(读取服务器上的静态资源文件内容返回给客户端)改成golang实现。然后对比一下效果。</p>
<h2 id="u5B9E_u73B0_u5BF9_u6BD4"><a href="#u5B9E_u73B0_u5BF9_u6BD4" class="headerlink" title="实现对比"></a>实现对比</h2><p>同样使用标准库,golang实现代码+注释只需要123行,C实现代码+注释412行，golang代码量只有C的1/3。</p>
<h2 id="u6D4B_u8BD5_u5BF9_u6BD4"><a href="#u6D4B_u8BD5_u5BF9_u6BD4" class="headerlink" title="测试对比"></a>测试对比</h2><p>我使用的是jmeter测试，首先测试c实现的服务,分别用100,200,300线程并发，每线程访问10。测试数据如下:<br><img src="/img/go-1.png" alt="c"></p>
<p><img src="/img/go-2.png" alt="c"></p>
<p><img src="/img/go-3.png" alt="c"><br>C版实现越测数据越看不下去了，出错率越来越大。接着我测golang实现，我分别用300线程，1000线程和5000线程并发，每线程访问10次。测试数据如下:<br><img src="/img/go-4.png" alt="c"></p>
<p><img src="/img/go-5.png" alt="c"></p>
<p><img src="/img/go-6.png" alt="c"><br>除了响应时间延长，其它都比较稳定，出错率全为0.难道这是传说中的后端神器，难道老板再也不用担心网站访问人数太多当机了，难道我也转golang开发。<br><a id="more"></a></p>
<h2 id="golang_u5B9E_u73B0"><a href="#golang_u5B9E_u73B0" class="headerlink" title="golang实现"></a>golang实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"path/filepath"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> realPath <span class="typename">string</span> <span class="comment">//当前程序运行目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">www路由，请求处理 w:response  r:request</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">func</span> staticResource(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"url:"</span> + r.RequestURI)</span><br><span class="line">	<span class="keyword">if</span> r.Method == <span class="string">"get"</span> || r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">		disposeGet(w, r)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> r.Method == <span class="string">"post"</span> || r.Method == <span class="string">"POST"</span> &#123;</span><br><span class="line">		disposePost(w, r)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		w.WriteHeader(<span class="number">501</span>)</span><br><span class="line">		w.Write([]<span class="typename">byte</span>(<span class="string">"&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.&lt;/BODY&gt;&lt;/HTML&gt;"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">取字串 s:字符串 l:取到多少位</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">func</span> substr(s <span class="typename">string</span>, l <span class="typename">int</span>) <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= l &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line">	ss, sl, rl, rs := <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, []<span class="typename">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> rs &#123;</span><br><span class="line">		rint := <span class="typename">int</span>(r)</span><br><span class="line">		<span class="keyword">if</span> rint &lt; <span class="number">128</span> &#123;</span><br><span class="line">			rl = <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rl = <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sl+rl &gt; l &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sl += rl</span><br><span class="line">		ss += <span class="typename">string</span>(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ss</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">get获取静态资源 w: response r: request</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">func</span> disposeGet(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	request_type := r.URL.Path[strings.LastIndex(r.URL.Path, <span class="string">"."</span>):]</span><br><span class="line">	<span class="keyword">switch</span> request_type &#123; <span class="comment">//文件类型判断</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">".html"</span>:</span><br><span class="line">		w.Header().Set(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">".htm"</span>:</span><br><span class="line">		w.Header().Set(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">".css"</span>:</span><br><span class="line">		w.Header().Set(<span class="string">"content-type"</span>, <span class="string">"text/css"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">".js"</span>:</span><br><span class="line">		w.Header().Set(<span class="string">"content-type"</span>, <span class="string">"text/javascript"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">".png"</span>:</span><br><span class="line">		w.Header().Set(<span class="string">"content-type"</span>, <span class="string">"image/png"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">".gif"</span>:</span><br><span class="line">		w.Header().Set(<span class="string">"content-type"</span>, <span class="string">"image/gif"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">".jpg"</span>:</span><br><span class="line">		w.Header().Set(<span class="string">"content-type"</span>, <span class="string">"image/jpeg"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">	fin, err := os.Open(realPath + r.URL.Path)</span><br><span class="line">	<span class="keyword">defer</span> fin.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123; <span class="comment">//未找到静态资源文件</span></span><br><span class="line">		<span class="keyword">if</span> request_type == <span class="string">".html"</span> || request_type == <span class="string">".htm"</span> &#123; <span class="comment">//未找到html文件</span></span><br><span class="line">			w.WriteHeader(<span class="number">404</span>)</span><br><span class="line">			fmt.Println(<span class="string">"static resource:"</span>, err)</span><br><span class="line">			w.Write([]<span class="typename">byte</span>(<span class="string">"&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;BODY&gt;&lt;P&gt;The server could not fulfill.your request be.is unavailable or nonexistent.&lt;/BODY&gt;&lt;/HTML&gt;"</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fd, _ := ioutil.ReadAll(fin)</span><br><span class="line">	w.Write(fd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">post上传静态资源 w: response r: request</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">func</span> disposePost(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	<span class="comment">//未实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">程序入口</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="comment">//获取程序当前路径</span></span><br><span class="line">	file, _ := exec.LookPath(os.Args[<span class="number">0</span>])</span><br><span class="line">	path, _ := filepath.Abs(file)</span><br><span class="line">	<span class="comment">//命令行参数处理</span></span><br><span class="line">	arg_num := <span class="built_in">len</span>(os.Args)</span><br><span class="line">	<span class="keyword">if</span> arg_num == <span class="number">2</span> &#123;</span><br><span class="line">		port := os.Args[<span class="number">1</span>] <span class="comment">//第一个参数为端口号</span></span><br><span class="line">		fmt.Println(<span class="string">"http server start port:"</span> + port)</span><br><span class="line">		<span class="comment">//取前当前目录</span></span><br><span class="line">		realPath = substr(path, strings.LastIndex(path, <span class="string">"\\"</span>))</span><br><span class="line">		flag.Parse()</span><br><span class="line">		<span class="comment">//请求处理</span></span><br><span class="line">		http.HandleFunc(<span class="string">"/www/"</span>, staticResource)</span><br><span class="line">		err := http.ListenAndServe(<span class="string">":"</span>+port, <span class="constant">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"服务器出错:"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"参数错误，程序退出"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>周末有人介绍golang很合适后端开发，随即把之前C实现的静态资源下载功能(读取服务器上的静态资源文件内容返回给客户端)改成golang实现。然后对比一下效果。</p>
<h2 id="u5B9E_u73B0_u5BF9_u6BD4"><a href="#u5B9E_u73B0_u5BF9_u6BD4" class="headerlink" title="实现对比"></a>实现对比</h2><p>同样使用标准库,golang实现代码+注释只需要123行,C实现代码+注释412行，golang代码量只有C的1/3。</p>
<h2 id="u6D4B_u8BD5_u5BF9_u6BD4"><a href="#u6D4B_u8BD5_u5BF9_u6BD4" class="headerlink" title="测试对比"></a>测试对比</h2><p>我使用的是jmeter测试，首先测试c实现的服务,分别用100,200,300线程并发，每线程访问10。测试数据如下:<br><img src="/img/go-1.png" alt="c"></p>
<p><img src="/img/go-2.png" alt="c"></p>
<p><img src="/img/go-3.png" alt="c"><br>C版实现越测数据越看不下去了，出错率越来越大。接着我测golang实现，我分别用300线程，1000线程和5000线程并发，每线程访问10次。测试数据如下:<br><img src="/img/go-4.png" alt="c"></p>
<p><img src="/img/go-5.png" alt="c"></p>
<p><img src="/img/go-6.png" alt="c"><br>除了响应时间延长，其它都比较稳定，出错率全为0.难道这是传说中的后端神器，难道老板再也不用担心网站访问人数太多当机了，难道我也转golang开发。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[英语入门视频推荐]]></title>
    <link href="http://binyanbin.github.io/2016/05/06/english-1/"/>
    <id>http://binyanbin.github.io/2016/05/06/english-1/</id>
    <published>2016-05-05T16:00:00.000Z</published>
    <updated>2016-05-08T15:14:11.662Z</updated>
    <content type="html"><![CDATA[<p>坚持学习英语也有一年多时间，除了在线外教学习，还看一些原版英语课程和英语电视剧，下面我分享2个非常非常非常合适初学者的系列视频’Learn English with Jennifer’和’extro English’。<br><a id="more"></a></p>
<h2 id="Learn_English_with_Jennifer"><a href="#Learn_English_with_Jennifer" class="headerlink" title="Learn English with Jennifer"></a>Learn English with Jennifer</h2><p><img src="/img/english-1.png" alt="Learn English with Jennifer"><br>一个美国英语教师教授一个俄罗斯人英语的教学视频，只有英文字幕，不用看字幕也很容易看懂听懂，非常合适初学者，作为入门视频课程非常合适。<br><a href="http://video.1speaking.com/view/index335.html" target="_blank" rel="external">观看地址</a></p>
<h2 id="extro_English"><a href="#extro_English" class="headerlink" title="extro English"></a>extro English</h2><p><img src="/img/english-2.jpg" alt="extro English"><br>这是一个搞笑情景剧,描述几个年轻人浪漫而搞笑的生活故事,可以让你从头笑到尾,只有英文字幕,超级易懂,适合初级或中级能力的学习,对于提高口语和听力具有很好的帮助。<br><a href="http://video.1speaking.com/view/index418.html" target="_blank" rel="external">观看地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>坚持学习英语也有一年多时间，除了在线外教学习，还看一些原版英语课程和英语电视剧，下面我分享2个非常非常非常合适初学者的系列视频’Learn English with Jennifer’和’extro English’。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C#由内存模型说性能2 数组与集合]]></title>
    <link href="http://binyanbin.github.io/2016/05/02/CSharp-2/"/>
    <id>http://binyanbin.github.io/2016/05/02/CSharp-2/</id>
    <published>2016-05-01T16:00:00.000Z</published>
    <updated>2016-05-01T05:40:13.704Z</updated>
    <content type="html"><![CDATA[<p>由于.net不会实时回收内存，那么.net对数组与集合是内存的是怎么处理的</p>
<h2 id="u6570_u7EC4_u4E0E_u96C6_u5408"><a href="#u6570_u7EC4_u4E0E_u96C6_u5408" class="headerlink" title="数组与集合"></a>数组与集合</h2><p>大家都知道数组必须指定大小，而且大小一但指定就不能更改了，也就是说数组不能动态的增加容量，那么对于一些需要动态增加容量的需求是实现不了的。实现动态扩容的需求都是通过集合,如List,Dictionary,ArrayList.<br><a id="more"></a></p>
<h2 id="u96C6_u5408_u5982_u4F55_u5B9E_u73B0_u52A8_u6001_u6269_u5BB9"><a href="#u96C6_u5408_u5982_u4F55_u5B9E_u73B0_u52A8_u6001_u6269_u5BB9" class="headerlink" title="集合如何实现动态扩容"></a>集合如何实现动态扩容</h2><p>拿ArrayList和List为例,实际的代码大概如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 增加元素</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">object</span> <span class="keyword">value</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//超出集合大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._size == <span class="keyword">this</span>._items.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.EnsureCapacity(<span class="keyword">this</span>._size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._items[<span class="keyword">this</span>._size] = <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">this</span>._version++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 设置容量大小 默认容量为4,超出容量则扩容2倍</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnsureCapacity</span>(<span class="params"><span class="keyword">int</span> min</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._items.Length &lt; min)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//默认容量为4,超出容量则扩容2倍</span></span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">this</span>._items.Length == <span class="number">0</span>) ? <span class="number">4</span> : (<span class="keyword">this</span>._items.Length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            num = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.Capacity = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 设置容量大小</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">int</span> Capacity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._items.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="keyword">this</span>._items.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="keyword">this</span>._size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">"value"</span>, Environment.GetResourceString(<span class="string">"ArgumentOutOfRange_SmallCapacity"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">object</span>[] array = <span class="keyword">new</span> <span class="keyword">object</span>[<span class="keyword">value</span>];<span class="comment">//重新分配内存</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>._size &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    Array.Copy(<span class="keyword">this</span>._items, <span class="number">0</span>, array, <span class="number">0</span>, <span class="keyword">this</span>._size); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>._items = array;</span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">this</span>._items = <span class="keyword">new</span> <span class="keyword">object</span>[<span class="number">4</span>]; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">list.Add(<span class="keyword">new</span> <span class="keyword">int</span>());<span class="comment">//list.Capacity=0</span></span><br><span class="line">list.Add(<span class="keyword">new</span> <span class="keyword">int</span>());<span class="comment">//list.Capacity=4</span></span><br><span class="line">list.Add(<span class="keyword">new</span> <span class="keyword">int</span>());<span class="comment">//list.Capacity=4</span></span><br><span class="line">list.Add(<span class="keyword">new</span> <span class="keyword">int</span>());<span class="comment">//list.Capacity=4</span></span><br><span class="line">list.Add(<span class="keyword">new</span> <span class="keyword">int</span>());<span class="comment">//list.Capacity=8</span></span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>无论是List,ArrayList或其它集合,不过是对Array的一层包装,也由此可以断定集合的性能肯定不如Array。</li>
<li>集合的扩容过程增加CPU的损耗和GC的压力，对于问题的严重性就取决于实际应用的场合，如果在高并发的应用下存在大量这操作那问题就变得严重多了。</li>
<li>使用:对集合初始化的时候指定容量,如果可以直接使用Array代替集合。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于.net不会实时回收内存，那么.net对数组与集合是内存的是怎么处理的</p>
<h2 id="u6570_u7EC4_u4E0E_u96C6_u5408"><a href="#u6570_u7EC4_u4E0E_u96C6_u5408" class="headerlink" title="数组与集合"></a>数组与集合</h2><p>大家都知道数组必须指定大小，而且大小一但指定就不能更改了，也就是说数组不能动态的增加容量，那么对于一些需要动态增加容量的需求是实现不了的。实现动态扩容的需求都是通过集合,如List,Dictionary,ArrayList.<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C#由内存模型说性能1]]></title>
    <link href="http://binyanbin.github.io/2016/04/30/CSharp-1/"/>
    <id>http://binyanbin.github.io/2016/04/30/CSharp-1/</id>
    <published>2016-04-29T16:00:00.000Z</published>
    <updated>2016-05-01T04:48:59.299Z</updated>
    <content type="html"><![CDATA[<p>C#不必手工管理内存，但要编写高性能的代码，就仍需理解后面发生的事情。</p>
<h2 id="u5185_u5B58_u6A21_u578B_3A_u5806_u4E0E_u6808"><a href="#u5185_u5B58_u6A21_u578B_3A_u5806_u4E0E_u6808" class="headerlink" title="内存模型:堆与栈"></a>内存模型:堆与栈</h2><p>C#内存主要有两类：Stack和Heap<br>Stack叫做栈区，由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>Heap则称之为堆区，由开发人员申请内存，在垃圾回收器的控制下工作。<br><img src="/img/CSharp-1.jpg" alt="效果"></p>
<a id="more"></a>
<h2 id="u503C_u7C7B_u578B_u4E0E_u5F15_u7528_u7C7B_u578B"><a href="#u503C_u7C7B_u578B_u4E0E_u5F15_u7528_u7C7B_u578B" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h2><p>值类型的数据和内存在同一个位置，而引用类型是一个指向内存的指针。也就是对Stack和Heap的实际使用。<br><img src="/img/CSharp-2.jpg" alt="效果"><br><img src="/img/CSharp-3.jpg" alt="效果"><br>除了Object和String,其它都是值类型。值类型的性能要略优于引用类型，它只需要一次访问内存就可拿到数据。</p>
<h2 id="u88C5_u7BB1_u4E0E_u62C6_u7BB1"><a href="#u88C5_u7BB1_u4E0E_u62C6_u7BB1" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>值类型与引用类型进行类型转换时会产生装箱和拆箱操作。<br><img src="/img/CSharp-4.jpg" alt="效果"><br>非必要时尽量避免这类操作，会对性能一定的影响。</p>
<h2 id="u5783_u573E_u56DE_u6536_u5668GC"><a href="#u5783_u573E_u56DE_u6536_u5668GC" class="headerlink" title="垃圾回收器GC"></a>垃圾回收器GC</h2><p>垃圾回收器为什么不会立即回收对象?<br>对象不再被引用时,如果立即删除,堆上的自由空间就会分散开来，给新对象分配内存就会很难处理,程序必须搜索整个堆才能找到一块足够大的内存块来存储整个新对象。<br>heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph。heap对应有一个Roots，它能使程序在heap之外可以找到的各种入口点。root包括:全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针。<br>下面可以通过一组图片来进一步了解GC的工作。黄色代表还在引用的对象，灰色代表没有引用的对象。<br>现在内存使用已达到阀值,GC需要清理内存，下图就是GC整个清理的过程。<br><img src="/img/CSharp-5.gif" alt="效果"><br><img src="/img/CSharp-6.gif" alt="效果"><br><img src="/img/CSharp-7.gif" alt="效果"><br><img src="/img/CSharp-8.gif" alt="效果"><br>GC回收内存是一种非常耗费性能的工作，减少不必要的内存使用有助于提高GC性能</p>
<h2 id="u4F20_u53C2_u7684_u4F18_u5316"><a href="#u4F20_u53C2_u7684_u4F18_u5316" class="headerlink" title="传参的优化"></a>传参的优化</h2><p>如果我们要将一个非常大的值类型数据(如数据量大的struct类型)入栈，它会占用非常大的内存空间，而且会占有过多的处理器资源来进行拷贝复制。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ConstNum</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> a,b,c,d,e,f,g,h,i,j,k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	ConstNum x = <span class="keyword">new</span> ConstNum();</span><br><span class="line">	Do(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Do</span>(<span class="params">ConstNum x</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以将struct改为class。实例对象之后则是引用类型。或使用ref关键字将方法改为Do(ref ConstNum x)，也可以达到引用类型的作用。</p>
<h2 id="u9759_u6001"><a href="#u9759_u6001" class="headerlink" title="静态"></a>静态</h2><p>有一个Dude类，你需要实例化多个对像使用。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Dude</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> _name =<span class="string">"test"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">//DoSomething</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp-9.gif" alt="效果"><br>你可以使用静态方法,以达到内存节省的目的。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Dude</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> _name =<span class="string">"test"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">//DoSomething</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp-10.gif" alt="效果"><br>实际项目中使用单例模式来达到省内存的目的。</p>
<h2 id="IDisposable_u4E0E_u6790_u6784_u51FD_u6570"><a href="#IDisposable_u4E0E_u6790_u6784_u51FD_u6570" class="headerlink" title="IDisposable与析构函数"></a>IDisposable与析构函数</h2><p>托管的资源只能由CG回收。而非托管的资源可以通过实现IDisposable进行释放。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CDisposable</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//析构函数，编译后变成 protected void Finalize()，GC会在回收对象前会调用调用该方法 </span></span><br><span class="line">    ~CDisposable() </span><br><span class="line">    &#123; </span><br><span class="line">        Dispose(<span class="keyword">false</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过实现该接口，显式地释放对象，只针对非托管对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>) </span><br><span class="line">    </span>&#123; </span><br><span class="line">        Dispose(<span class="keyword">true</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dispose调用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Using(MyClass myObj = <span class="keyword">new</span> CDisposable())</span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//DoSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接调myObj.Dispose();</p>
<h2 id="u5B57_u7B26_u4E32_u7684_u5185_u5B58_u89C4_u5219"><a href="#u5B57_u7B26_u4E32_u7684_u5185_u5B58_u89C4_u5219" class="headerlink" title="字符串的内存规则"></a>字符串的内存规则</h2><p>string是引用类型，但string的值是不可变，但你改变string值的时候会对新值重新分配内存,老值仍驻留在内存中。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> a = <span class="string">"1234"</span>;</span><br><span class="line">a += <span class="string">"5678"</span>;</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>
<p>看起来我们似乎已经把a的值从“1234”改为了“12345678”，实际上并没有改变。因为string的值是无法修改不了了。堆中其实存在着两个字符串对象。字符串“1234”仍然在内存中驻留。</p>
<p>string容易引起内存驻留，但我们仍有办法减少内存使用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> str1 = <span class="string">"ABCD1234"</span>;</span><br><span class="line"><span class="keyword">string</span> str2 = <span class="string">"ABCD1234"</span>;</span><br><span class="line"><span class="keyword">string</span> str3 = <span class="string">"ABCD"</span> + <span class="string">"1234"</span>; </span><br><span class="line"><span class="keyword">string</span> str4 = <span class="string">"1234"</span>;</span><br><span class="line"><span class="keyword">string</span> str5 = <span class="string">"ABCD"</span> + str4;</span><br><span class="line"><span class="keyword">object</span>.ReferenceEquals(str1, str2) == True；</span><br><span class="line"><span class="keyword">object</span>.ReferenceEquals(str1, str3) == True；</span><br><span class="line"><span class="keyword">object</span>.ReferenceEquals(str1, str5) == False</span><br></pre></td></tr></table></figure>
<p>通过上面比较，字符串都驻留在内存。尽量使用字符串相加来代替字符串变量和字符创相加，这样可以使用利用字符串驻留，减少内存使用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> str3 = <span class="string">"ABCD"</span> + <span class="string">"1234"</span>;</span><br></pre></td></tr></table></figure>
<p>对string作频繁的操作使用StringBuilder或string.format(也是StringBuilder实现)处理。<br>StringBuilder内部维护一个字符数组，而不是一个string来避免string操作带来的新的string的创建。</p>
<pre><code class="CSharp">StringBuilder sb = <span class="keyword">new</span> StringBuilder();
sb.Append(str1);
sb.Append(str2);
sb.Append(str3);
</code></pre>
<pre><code class="CSharp"><span class="keyword">string</span> sb = <span class="keyword">string</span>.format(<span class="string">"{0}{1}{2}"</span>,str1,str2,str3);
</code></pre>
<p>相当于sb = str1 + str2 + str3;</p>
<p>4.高效地进行string的比较操作<br>对象之间的比较有比较Value和比较Reference之说。一般地对Reference进行比较的速度最快，因为只需要比较一下是不是同一地址就行了。<br>object.ReferenceEquals和string. Compare就是引用比较的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>C#不必手工管理内存，但要编写高性能的代码，就仍需理解后面发生的事情。</p>
<h2 id="u5185_u5B58_u6A21_u578B_3A_u5806_u4E0E_u6808"><a href="#u5185_u5B58_u6A21_u578B_3A_u5806_u4E0E_u6808" class="headerlink" title="内存模型:堆与栈"></a>内存模型:堆与栈</h2><p>C#内存主要有两类：Stack和Heap<br>Stack叫做栈区，由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>Heap则称之为堆区，由开发人员申请内存，在垃圾回收器的控制下工作。<br><img src="/img/CSharp-1.jpg" alt="效果"></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈Himall商城限时购设计]]></title>
    <link href="http://binyanbin.github.io/2016/04/21/hishop-1/"/>
    <id>http://binyanbin.github.io/2016/04/21/hishop-1/</id>
    <published>2016-04-20T16:00:00.000Z</published>
    <updated>2016-04-20T16:51:02.732Z</updated>
    <content type="html"><![CDATA[<p>互联网正在高速发展，使用互联网服务的用户越多，高并发的场景也变得越来越多。<a href="http://www.hishop.com.cn/products/himall/" target="_blank" rel="external">Himall</a>限时购功能则是一个典型的短时间高并发场景。虽然我们解决问题的具体技术方案可能千差万别，但是遇到的挑战却是相似的，因此解决问题的思路也异曲同工。<br>什么是限时购?限时购跟大部分电商抢购业务相同,即限时且限量抢购。不管小米还是华为，或是其它电商公司，对抢购业务运营总是最为火爆，每发一款新品，都限量发售，每次搞的大家心里痒痒的。抢购太火爆有时引起站点打不开，崩溃了;还有就是卖出的数量比设置可购买的数量要多。那么问题来了：我们如何在设计中如何解决。通常我们需要从设计中考虑以下问题:</p>
<ul>
<li>针对高并发，我们如何解耦后端压力，特别是数据库的压力。</li>
<li>如何保障库存可靠。<a id="more"></a>
</li>
</ul>
<p>我们可以试想一下抢购时哪些页面会请求最多。抢购之前人们通常会通常刷页面等待，一般在抢购开始前一点时间会频繁刷新抢购倒数的页面或购买详情页面。抢购开始以后前一段时间下单的人会很多。付款并发量相对较小，通常订单在下单后几小时内都能付款，缓解了并发压力。针对以上问题及场景，我们做了以下处理，增加限时购缓存订单系统，去支持限时购高并发处理，并保持限时购业务的可靠性。<br><img src="/img/hishop-1.png" alt="图1"></p>
<p><a href="http://www.hishop.com.cn/products/himall/" target="_blank" rel="external">Hiamll</a>在2.3版本做了如下改进:<br>1.引入Redis做缓存。<br>2.在用户抢购开始前频繁刷页面时,系统只从缓存中取商品数据，解耦了数据库查询的压力。<br>3.用户下单时系统只把订单数据存入订单缓存队列后然后告诉用户你的订单正在处理。然后由Redis Pub/Sub服务通知Web服务器，服务器把库存订单进行串行化处理，解耦数据库并发下单压力，保证库存可靠。<br>4.支付功能保持原来实现不变。</p>
<p>具体实现如下:<br>买家前端查询限时购商品数据时只走缓存。<br><img src="/img/hishop-2.png" alt="图2"><br>卖家后台更新限时购或库存信息时需同步更新数据库及缓存。<br><img src="/img/hishop-3.png" alt="图3"><br>系统为每个正在开卖的限时购商品库存创建锁，买家对某库存下单时锁住该库存的下单操作，每一个商品库存只允许一个会员下单，下单的订单数据直接加入订单缓存后告诉买家[您的订单正在处理,请稍等]。然后通过Redis Pub/Sub服务通知服务器处理订单，将订单按库存串行化处理，订单处理完成后，则更新限时购订单缓存的处理状态。<br><img src="/img/hishop-4.png" alt="图4"><br>买家得知订单正在处理后，则不断查询缓存的订单处理状态。直到获取订单处理结果，下单成功则进行支付页面，失败则提示失败原因并引导买家重新下单。<br><img src="/img/hishop-5.png" alt="图5"><br>最后就是在Web服务启动时，需要对限时购订单缓存系统初始化，把商品数据加入缓存中，并处理上次未处理完成的订单。<br><img src="/img/hishop-6.png" alt="图6"></p>
<p>总结:无论你用什么方式处理性能问题，性能优化的核心思想是分治。这种思想在日常生活中无处不在，大家都知道一次做不了的事，就分多次做，这就是分治。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>互联网正在高速发展，使用互联网服务的用户越多，高并发的场景也变得越来越多。<a href="http://www.hishop.com.cn/products/himall/">Himall</a>限时购功能则是一个典型的短时间高并发场景。虽然我们解决问题的具体技术方案可能千差万别，但是遇到的挑战却是相似的，因此解决问题的思路也异曲同工。<br>什么是限时购?限时购跟大部分电商抢购业务相同,即限时且限量抢购。不管小米还是华为，或是其它电商公司，对抢购业务运营总是最为火爆，每发一款新品，都限量发售，每次搞的大家心里痒痒的。抢购太火爆有时引起站点打不开，崩溃了;还有就是卖出的数量比设置可购买的数量要多。那么问题来了：我们如何在设计中如何解决。通常我们需要从设计中考虑以下问题:</p>
<ul>
<li>针对高并发，我们如何解耦后端压力，特别是数据库的压力。</li>
<li>如何保障库存可靠。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C windows版开源http服务]]></title>
    <link href="http://binyanbin.github.io/2016/04/17/c-7/"/>
    <id>http://binyanbin.github.io/2016/04/17/c-7/</id>
    <published>2016-04-16T16:00:00.000Z</published>
    <updated>2016-05-06T13:58:24.499Z</updated>
    <content type="html"><![CDATA[<h2 id="minhttpd"><a href="#minhttpd" class="headerlink" title="minhttpd"></a>minhttpd</h2><p><a href="https://github.com/binyanbin/minihttpd" target="_blank" rel="external">minihttpd</a>一个超小型静态资源http服务器,,去掉注释及空行的剩余代码量小于300行。可支持windows和linux gcc编译。</p>
<h4 id="u529F_u80FD_u53CA_u76EE_u7684"><a href="#u529F_u80FD_u53CA_u76EE_u7684" class="headerlink" title="功能及目的"></a>功能及目的</h4><p>此服务的功能仅支持静态资源上传与下载，如图片,js,html,css等静态资源，以此作为单独静态资源服务器使用,使静态资源与web主服务器分离。这个服务也可以让你更了解http服务器的运作方式及基本原理,也是用纯C开发网络服务的一个示例。</p>
<h4 id="windwos_MinGW_u7F16_u8BD1_3A"><a href="#windwos_MinGW_u7F16_u8BD1_3A" class="headerlink" title="windwos MinGW编译:"></a>windwos MinGW编译:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o http http.c <span class="operator">-l</span> wsock32</span><br></pre></td></tr></table></figure>
<h4 id="u7AD9_u70B9_u642D_u5EFA"><a href="#u7AD9_u70B9_u642D_u5EFA" class="headerlink" title="站点搭建"></a>站点搭建</h4><p>站点搭建:<br>创建站点目录，把http.exe复制到目录下，创建www目录并把网站的所有静态页面copy到目录下。<br>启动服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http <span class="number">8080</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u5386_u53F2"><a href="#u5386_u53F2" class="headerlink" title="历史"></a>历史</h4><p>v0.1.0 第一个版本，支持动词get及html。 [2016-4-17]<br>v0.1.1 支持图片(最大为1m),css。[2016-5-4]</p>
<p><a href="https://github.com/binyanbin/minihttpd" target="_blank" rel="external">源码查看</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="minhttpd"><a href="#minhttpd" class="headerlink" title="minhttpd"></a>minhttpd</h2><p><a href="https://github.com/binyanbin/minihttp]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言之socket 简易客户端]]></title>
    <link href="http://binyanbin.github.io/2016/04/13/c-6/"/>
    <id>http://binyanbin.github.io/2016/04/13/c-6/</id>
    <published>2016-04-12T16:00:00.000Z</published>
    <updated>2016-04-17T06:47:53.525Z</updated>
    <content type="html"><![CDATA[<p>昨天做了一个简易服务端，今天尝试做一个简易客户端，东西比较少，很顺利就完成了。客户端socket操作步骤:1.创建socket 2.连接服务端 3.接收服务端返回数据</p>
<h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><p>1.连接:<br>int connect(int fd, const struct sockaddr* addr, socklen_t address_len));<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>address_len：确定address缓冲区的长度<br>返回值：如果函数执行成功，返回值为0，否则为-1。</p>
<p>2.接收<br>int recv(SOCKET socket, char FAR* buf, int len, int flags);<br>socket：一个标识已连接套接口的描述字。<br>buf：用于接收数据的缓冲区。<br>len：缓冲区长度。<br>flags：指定调用方式。<br>返回值：若无错误发生,recv()返回读入的字节数.如果连接已中止，返回0.否则的话,返回SOCKET_ERROR错误.</p>
<a id="more"></a>
<h1 id="u670D_u52A1_u7AEF_u793A_u4F8B"><a href="#u670D_u52A1_u7AEF_u793A_u4F8B" class="headerlink" title="服务端示例"></a>服务端示例</h1><p>新建client.c文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MINGW32</span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXLINE <span class="number">1024</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd,n;</span><br><span class="line">	<span class="keyword">char</span> receline[MAXLINE+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in serveraddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输入参数太少，退出</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage :%s IP_address\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line">	<span class="comment">//Winsows下启用socket</span></span><br><span class="line">	WSADATA wsadata;</span><br><span class="line">	<span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">1</span>,<span class="number">1</span>),&amp;wsadata)==SOCKET_ERROR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WSAStartup() fail\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立socket</span></span><br><span class="line">	<span class="keyword">if</span>((sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>))==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"socket() fail\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置协议及Port</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serveraddr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">	serveraddr.sin_family = AF_INET;</span><br><span class="line">	serveraddr.sin_port=htons(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置IP</span></span><br><span class="line">	serveraddr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接</span></span><br><span class="line">	<span class="keyword">if</span>(connect(sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr))==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"connect() fail\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取数据并输入到标准输出</span></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line">	<span class="keyword">while</span>((n=recv(sockfd,receline,MAXLINE,<span class="number">0</span>))&gt;<span class="number">0</span>)</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">while</span>((n=read(sockfd,receline,MAXLINE))&gt;<span class="number">0</span>)</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123; </span><br><span class="line">		receline[n]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fputs</span>(receline,<span class="built_in">stdout</span>)==EOF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"fputs() error\r\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//没有获取数据</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"read() fail\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line">	<span class="comment">//Winsows下关闭socket</span></span><br><span class="line">	closesocket(sockfd);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译:gcc -g -o client client.c -l wsock32<br>执行:<br>服务端 server<br>客户端连接 client 127.0.0.1</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天做了一个简易服务端，今天尝试做一个简易客户端，东西比较少，很顺利就完成了。客户端socket操作步骤:1.创建socket 2.连接服务端 3.接收服务端返回数据</p>
<h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><p>1.连接:<br>int connect(int fd, const struct sockaddr* addr, socklen_t address_len));<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>address_len：确定address缓冲区的长度<br>返回值：如果函数执行成功，返回值为0，否则为-1。</p>
<p>2.接收<br>int recv(SOCKET socket, char FAR* buf, int len, int flags);<br>socket：一个标识已连接套接口的描述字。<br>buf：用于接收数据的缓冲区。<br>len：缓冲区长度。<br>flags：指定调用方式。<br>返回值：若无错误发生,recv()返回读入的字节数.如果连接已中止，返回0.否则的话,返回SOCKET_ERROR错误.</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言之socket 简易服务端]]></title>
    <link href="http://binyanbin.github.io/2016/04/12/c-5/"/>
    <id>http://binyanbin.github.io/2016/04/12/c-5/</id>
    <published>2016-04-11T16:00:00.000Z</published>
    <updated>2016-04-17T06:47:56.916Z</updated>
    <content type="html"><![CDATA[<p>今年有两个目标，一个是做开源项目，第二个是用C写一个网络服务。C写网络服务Socket是基础，首先需要了解socket的用法。服务端socket操作步骤:1.创建socket,2.绑定地址及端口,3.接收请求,4.发送数据。</p>
<h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><p>1.创建socket:<br>int socket(int domain, int type, int protocol);<br>domain：协议域<br>type：指定Socket类型。<br>protocol：指定协议。<br>返回值：如果调用成功就返回新创建的套接字的描述符，如果失败就返回-1。</p>
<p>2.绑定地址级端口<br>int bind(SOCKET socket, const struct sockaddr* address, socklen_t address_len);<br>参数说明：<br>socket：是一个套接字描述符。<br>address：是一个sockaddr结构指针，该结构中包含了要结合的地址和端口号。<br>address_len：确定address缓冲区的长度。<br>返回值：如果函数执行成功，返回值为0，否则为SOCKET_ERROR。</p>
<p>3.接收连接请求<br>int accept( int fd, struct socketaddr<em> addr, socklen_t</em> len);<br>参数说明：<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>len：接收返回地址的缓冲区长度<br>返回值：成功返回客户端的文件描述符，失败返回-1。</p>
<p>4.发送数据<br>int send(int fd, const void * msg, int len, unsigned int falgs);<br>fd：套接字描述符。<br>msg: 数据内容。<br>len: 数据长度。<br>返回值：成功则返回实际传送出去的字符数, 失败返回-1.</p>
<a id="more"></a>
<h1 id="u670D_u52A1_u7AEF_u793A_u4F8B"><a href="#u670D_u52A1_u7AEF_u793A_u4F8B" class="headerlink" title="服务端示例"></a>服务端示例</h1><p>新建server.c文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MINGW32</span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LISTENQ <span class="number">10</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//serverfd服务端套接字描述符，connectfd客户端套接字描述符</span></span><br><span class="line">	<span class="keyword">int</span> serverfd,connectfd;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in serveraddr;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">time_t</span> tlick;</span><br><span class="line">	<span class="keyword">int</span> iRet;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line">	<span class="comment">//Winsows下启用socket</span></span><br><span class="line">	WSADATA wsadata;</span><br><span class="line">	<span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">1</span>,<span class="number">1</span>),&amp;wsadata)==SOCKET_ERROR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WSAStartup() fail\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//新建server socket</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"socket()\n"</span>);</span><br><span class="line">	<span class="comment">//SOCK_STREAM提供面向连接的稳定数据传输，即TCP协议</span></span><br><span class="line">	serverfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(serverfd==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"socket() fail\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清零</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serveraddr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置协议 AF_INET:ipv4地址（32位的）与端口号（16位的）的组合</span></span><br><span class="line">	serveraddr.sin_family=AF_INET;</span><br><span class="line">	<span class="comment">//设置IP 127.0.0.1</span></span><br><span class="line">	serveraddr.sin_addr.s_addr=inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">	<span class="comment">//设置Port</span></span><br><span class="line">	serveraddr.sin_port=htons(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定端口，监听1024端口的任何请求</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bind()\n"</span>);</span><br><span class="line">	iRet=bind(serverfd,(<span class="keyword">struct</span> sockaddr*)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">	<span class="keyword">if</span>(iRet==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind() fail\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听端口，最大并发数10</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"listen()\n"</span>);</span><br><span class="line">	iRet=listen(serverfd,LISTENQ);</span><br><span class="line">	<span class="keyword">if</span>(iRet==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"listen() fail\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//接受请求，发送主机时间</span></span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Waiting for connection...\n"</span>);</span><br><span class="line">		<span class="comment">//接受请求</span></span><br><span class="line">		connectfd=accept(serverfd,(<span class="keyword">struct</span> sockaddr*)<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">//获取时间 </span></span><br><span class="line">		tlick=time(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">//格式化时间 </span></span><br><span class="line">		<span class="built_in">snprintf</span>(buff,<span class="keyword">sizeof</span>(buff),<span class="string">"From mys:\n%s"</span>,ctime(&amp;tlick));</span><br><span class="line">		<span class="comment">//写入时间</span></span><br><span class="line">		<span class="comment">//关闭请求</span></span><br><span class="line">		<span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line">		send(connectfd,buff,<span class="built_in">strlen</span>(buff),<span class="number">0</span>);</span><br><span class="line">		closesocket(connectfd);</span><br><span class="line">		<span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		write(connectfd,buff,<span class="built_in">strlen</span>(buff));</span><br><span class="line">		close(connectfd);</span><br><span class="line">		<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> MINGW32</span></span><br><span class="line">	<span class="comment">//Winsows下关闭socket</span></span><br><span class="line">	closesocket(serverfd);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//退出</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译:gcc -g -o server server.c -l wsock32</p>
<p>如果你装了MinGW,你也可以尝试一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今年有两个目标，一个是做开源项目，第二个是用C写一个网络服务。C写网络服务Socket是基础，首先需要了解socket的用法。服务端socket操作步骤:1.创建socket,2.绑定地址及端口,3.接收请求,4.发送数据。</p>
<h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><p>1.创建socket:<br>int socket(int domain, int type, int protocol);<br>domain：协议域<br>type：指定Socket类型。<br>protocol：指定协议。<br>返回值：如果调用成功就返回新创建的套接字的描述符，如果失败就返回-1。</p>
<p>2.绑定地址级端口<br>int bind(SOCKET socket, const struct sockaddr* address, socklen_t address_len);<br>参数说明：<br>socket：是一个套接字描述符。<br>address：是一个sockaddr结构指针，该结构中包含了要结合的地址和端口号。<br>address_len：确定address缓冲区的长度。<br>返回值：如果函数执行成功，返回值为0，否则为SOCKET_ERROR。</p>
<p>3.接收连接请求<br>int accept( int fd, struct socketaddr<em> addr, socklen_t</em> len);<br>参数说明：<br>fd：套接字描述符。<br>addr：返回连接着的地址<br>len：接收返回地址的缓冲区长度<br>返回值：成功返回客户端的文件描述符，失败返回-1。</p>
<p>4.发送数据<br>int send(int fd, const void * msg, int len, unsigned int falgs);<br>fd：套接字描述符。<br>msg: 数据内容。<br>len: 数据长度。<br>返回值：成功则返回实际传送出去的字符数, 失败返回-1.</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言之函数库]]></title>
    <link href="http://binyanbin.github.io/2016/03/31/c-4/"/>
    <id>http://binyanbin.github.io/2016/03/31/c-4/</id>
    <published>2016-03-30T16:00:00.000Z</published>
    <updated>2016-03-31T15:52:03.258Z</updated>
    <content type="html"><![CDATA[<p>为什么写C的需要了解更多系统方面的知识，我们可以从C语言的函数库说起。</p>
<h1 id="C_u6807_u51C6_u5E93"><a href="#C_u6807_u51C6_u5E93" class="headerlink" title="C标准库"></a>C标准库</h1><p>C标准库，顾名思义既然是标准，就是由标准组织制定的。C标准库就是任何平台都可以使用的基本C语言库。<br>标准库是C标准定义了一系列常用的函数，称为C库函数。C标准仅仅定义了函数原型，并没有提供实现。因此这个任务留给了各个支持C语言标准的编译器。你只使用标准库写的代码可以跨平台使用。</p>
<h1 id="u8FD0_u884C_u5E93"><a href="#u8FD0_u884C_u5E93" class="headerlink" title="运行库"></a>运行库</h1><p>它由不同操作系统不同开发平台提供不同的C运行库。但是C运行库的部分实现是基于C标准库的，即C运行库是各个操作系统各个开发工具根据自身平台开发的库，某种程度上，可以说C运行库是C标准库的一个扩展库，只是加了很多C标准库所没有的与平台相关的或者不相关的库接口函数。<br>一个运行库包括以下功能:<br>1.启动与退出：包括入口函数及入口函数所依赖的其他函数等。<br>2.标准函数：由C语言标准规定的C语言标准库所拥有的函数实现。（C标准库）<br>3.I/O：I/O功能的封装和实现，参见上一节中I/O初始化部分。<br>4.堆：堆的封装和实现，参见上一节中堆初始化部分。<br>5.语言实现：语言中一些特殊功能的实现。<br>6.调试：实现调试功能的代码。</p>
<ul>
<li>运行库是平台相关的，因为它与操作系统结合得非常紧密。C语言的运行库从某种程度上来讲是C语言的程序和不同操作系统平台之间的抽象层，它将不同的操作系统API抽象成相同的库函数。比如我们可以在不同的操作系统平台下使用fread来读取文件，而事实上fread(标准库函数)在不同的操作系统平台下的实现是不同的，但作为运行库的使用者我们不需要关心这一点。</li>
<li>虽然各个平台下的C语言运行库提供了很多功能，但很多时候它们毕竟有限，比如用户的权限控制等都不是属于标准的C语言运行库。于是我们不得不通过其他的办法，诸如绕过C语言运行库直接调用操作系统API或使用其他的库。</li>
<li>linux和Windows平台下的两个主要C语言运行库分别为glibc（GNU C Library）和MSVCRT（Microsoft Visual C Run-time），我们在下面将会分别介绍它们。值得注意的是，像线程操作这样的功能并不是标准的C语言运行库的一部分，但是glibc和MSVCRT都包含了线程操作的库函数。比如glibc有一个可选的pthread库中的pthread_create()函数可以用来创建线程；而MSVCRT中可以使用_beginthread()函数来创建线程。所以glibc和MSVCRT事实上是标准C语言运行库的超集，它们各自对C标准库进行了一些扩展。<br><img src="/img/c-6.jpg" alt="关系图"></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>为什么写C的需要了解更多系统方面的知识，我们可以从C语言的函数库说起。</p>
<h1 id="C_u6807_u51C6_u5E93"><a href="#C_u6807_u51C6_u5E93" class="headerlink" title="C标准库"></a>C]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言之由内存模型说起]]></title>
    <link href="http://binyanbin.github.io/2016/03/25/c-3/"/>
    <id>http://binyanbin.github.io/2016/03/25/c-3/</id>
    <published>2016-03-24T16:00:00.000Z</published>
    <updated>2016-04-28T13:39:46.485Z</updated>
    <content type="html"><![CDATA[<p>说起内存模型，那就先要介绍程序运行时是如何管理内存的。<br>程序运行时:</p>
<ul>
<li>系统先把物理硬盘代码load到内存</li>
<li>系统再把c代码分成四个区</li>
<li>系统再找到main函数入口执行<h2 id="u7A0B_u5E8F_u7684_u56DB_u533A_u6A21_u578B"><a href="#u7A0B_u5E8F_u7684_u56DB_u533A_u6A21_u578B" class="headerlink" title="程序的四区模型"></a>程序的四区模型</h2><img src="/img/c-3.png" alt="效果"><a id="more"></a>
一个由C编译的程序的内存分配通常由以下几块组成:<br>1 栈区(stack)由编译器自动分配释放,存放函数的参数值,局部变量的值等。其操作方式类似于数据结构中的栈。<br>2 堆区(heap):一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3 全局区：主要包括静态全局区和常量区，程序结束后由系统释放。<br>静态区(static):全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域,未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。<br>常量区:常量字符串就是放在这里的。<br>4 代码区：存放函数体的二进制代码。<br>示例:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">fa</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>*pa = <span class="string">"123456"</span>;<span class="comment">//pa指针在栈区，“123456”在常量区，该函数调用完后指针变量pa就被释放了</span></span><br><span class="line">    <span class="keyword">char</span>*p = <span class="literal">NULL</span>;<span class="comment">//指针变量p在栈中分配4字节</span></span><br><span class="line">    p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//本函数在这里开辟了一块堆区的内存空间，并把地址赋值给p</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">"wudunxiong 1234566"</span>);<span class="comment">//把常量区的字符串拷贝到堆区</span></span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//返回给主调函数fb()，相对fa来说fb是主调函数，相对main来说，fa(),fb()都是被调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由此可以得知，当一个程序运行时，他的全局区，代码区基本是固定不变的，堆区与全局区和代码区均由系统控制。开发人员需对堆区内存进行管理。在现代开发语言(java,c#,javascript等)里,堆区内存管理都是由垃圾回收器处理的。</p>
<h2 id="u5185_u5B58_u7BA1_u7406_u57FA_u7840_3A_u6307_u9488"><a href="#u5185_u5B58_u7BA1_u7406_u57FA_u7840_3A_u6307_u9488" class="headerlink" title="内存管理基础:指针"></a>内存管理基础:指针</h2><p>指针是一个变量,其值为另一个变量的地址,即内存位置的直接地址。就像其他变量或常量一样,您必须在使用指针存储其他变量地址之前,对其进行声明。指针变量声明的一般形式为：type *var-name;<br>示例如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="keyword">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Address of var variable: %x\n"</span>, &amp;var  );</span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Address stored in ip variable: %x\n"</span>, ip );</span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of *ip variable: %d\n"</span>, *ip );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5B57_u7B26_u4E32"><a href="#u5B57_u7B26_u4E32" class="headerlink" title="字符串"></a>字符串</h2><p>在C语言中,字符串实际上是使用null字符 ‘\0’ 终止的一维字符数组.因此,一个以null尾的字符串,包含了组成字符串的字符.<br>下面的声明和初始化创建了一个”Hello”字符串.由于在数组的末尾存储了空字符,所以字符数组的大小比单词”Hello”的字符数多一个。<br><img src="/img/c-4.jpg" alt="效果"></p>
<p>c语言标准库没有常用的字符串方法，如indexOf,lastIndexOf,trim,lTrim,rTrim等方法。如是我就自己尝试实现，中间用了几个标准库函数:strcpy字符串拷贝，strcat字符串连接，这个方法不能直接用，C中的字符串内存不是自动扩展需要自己申请,strcat是把第二个字符串copy到第一个字符串结尾，需要第一个字符串分配的内存足够多，不然无法连接。strstr查找相同的字符串，返回的又是地址。整个代码全是内存操作，自已申请的内存一定要记得释放，对于用惯了现代语言的人来说，这真是相当虐心啊。<br><img src="/img/c-5.jpg" alt="效果"><br>还是看代码吧<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">///方法定义</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">join</span><span class="params">(<span class="keyword">char</span>  *s1,<span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">ltrim</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">rtrim</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">trim</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">    <span class="comment">//测试数据准备</span></span><br><span class="line">    <span class="keyword">char</span> *first;</span><br><span class="line">    <span class="keyword">char</span> *second;</span><br><span class="line">    <span class="keyword">char</span> *indexstr;</span><br><span class="line">    <span class="keyword">char</span> *third;</span><br><span class="line">    <span class="keyword">char</span> *show;</span><br><span class="line">    first = <span class="string">"binyanbin website is "</span>;</span><br><span class="line">    second = <span class="string">"http://binyanbin.github.io"</span>;</span><br><span class="line">    indexstr = <span class="string">"bin"</span>;</span><br><span class="line">    third = <span class="string">"  binyanbin trim test "</span>;</span><br><span class="line">    <span class="comment">//测试结果输出</span></span><br><span class="line">    show = join(first,second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"join(\"%s\",\"%s\")=\"%s\"\n"</span>,first,second,show);</span><br><span class="line">    <span class="built_in">free</span>(show);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"indexOf(\"%s\",\"%s\")=%d\n"</span>,second,indexstr,indexOf(second,indexstr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"lastIndexOf(\"%s\",\"%s\")=%d\n"</span>,second,indexstr,lastIndexOf(second,indexstr));</span><br><span class="line">    show = ltrim(third);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ltrim(\"%s\")=\"%s\"\n"</span>,third,show);</span><br><span class="line">    <span class="built_in">free</span>(show);</span><br><span class="line">    show = rtrim(third);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rtrim(\"%s\")=\"%s\"\n"</span>,third,show);</span><br><span class="line">    show = trim(third);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"trim(\"%s\")=\"%s\""</span>,third,show);</span><br><span class="line">    <span class="built_in">free</span>(show);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串连接</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">join</span><span class="params">(<span class="keyword">char</span>  *s1,<span class="keyword">char</span> *s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//分布内存</span></span><br><span class="line">    <span class="keyword">char</span> *result = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s1)+<span class="built_in">strlen</span>(s2)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (result==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//内存为空退出</span></span><br><span class="line">    <span class="comment">//拷贝s1到result</span></span><br><span class="line">    <span class="built_in">strcpy</span>(result, s1);</span><br><span class="line">    <span class="comment">//s2加到result尾部  </span></span><br><span class="line">    <span class="built_in">strcat</span>(result, s2);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串查询最开始位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *p=str1;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//p是一个地址，找到相同字符串的地址</span></span><br><span class="line">    p=<span class="built_in">strstr</span>(str1,str2);  </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="comment">//是不是同一个地址了，是同一地址则找到字符串</span></span><br><span class="line">        <span class="keyword">while</span>(str1!=p)</span><br><span class="line">        &#123;  </span><br><span class="line">            str1++;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> i;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查询最后位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *p=str1;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str2);  </span><br><span class="line">    p=<span class="built_in">strstr</span>(str1,str2);  </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//未找到字符串地址为空则跳出循环  </span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)  </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//跳过已找的地址 </span></span><br><span class="line">        <span class="keyword">for</span>(;str1!=p;str1++)</span><br><span class="line">            i++;  </span><br><span class="line">        p=p+len;</span><br><span class="line">        <span class="comment">//找出下一个同样字符串的地址  </span></span><br><span class="line">        p=<span class="built_in">strstr</span>(p,str2);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> i;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除左空格 </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ltrim</span><span class="params">(<span class="keyword">char</span> *param)</span>  </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//申请存储，不修改参数内存的数据</span></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(param)+<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, param); </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j,len=<span class="built_in">strlen</span>(str);  </span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">'\0'</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//32:空格,9:横向制表符</span></span><br><span class="line">        <span class="keyword">if</span>(str[i]!=<span class="number">32</span>&amp;&amp;str[i]!=<span class="number">9</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">0</span>)  </span><br><span class="line">    <span class="comment">//将后面的字符顺势前移,补充删掉的空白位置</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=len-i;j++)  </span><br><span class="line">    &#123;     </span><br><span class="line">        str[j]=str[j+i];</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> str; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//删除右空格</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">rtrim</span><span class="params">(<span class="keyword">char</span> *param)</span>  </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(param)+<span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">strcpy</span>(str, param); </span><br><span class="line">    <span class="keyword">char</span> *p=str;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="built_in">strlen</span>(str)-<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(p[i]!=<span class="number">32</span>&amp;&amp;p[i]!=<span class="number">9</span>)</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        i--;  </span><br><span class="line">    &#125;  </span><br><span class="line">    str[++i]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除左右空格</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">trim</span><span class="params">(<span class="keyword">char</span> *str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* temp = ltrim(str);</span><br><span class="line">    <span class="keyword">char</span>* result = rtrim(temp);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起内存模型，那就先要介绍程序运行时是如何管理内存的。<br>程序运行时:</p>
<ul>
<li>系统先把物理硬盘代码load到内存</li>
<li>系统再把c代码分成四个区</li>
<li>系统再找到main函数入口执行<h2 id="u7A0B_u5E8F_u7684_u56DB_u533A_u6A21_u578B"><a href="#u7A0B_u5E8F_u7684_u56DB_u533A_u6A21_u578B" class="headerlink" title="程序的四区模型"></a>程序的四区模型</h2><img src="/img/c-3.png" alt="效果">]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言之个性化termial]]></title>
    <link href="http://binyanbin.github.io/2016/03/24/c-2/"/>
    <id>http://binyanbin.github.io/2016/03/24/c-2/</id>
    <published>2016-03-23T16:00:00.000Z</published>
    <updated>2016-03-25T14:46:11.326Z</updated>
    <content type="html"><![CDATA[<p>很多牛人有自己的个性化的命令行，为什么我没有呢?晚上我就写了一个。效果如下:<br><img src="/img/c-1.png" alt="效果"><br><a id="more"></a></p>
<h2 id="u56FE_u5F62_u5B9E_u73B0"><a href="#u56FE_u5F62_u5B9E_u73B0" class="headerlink" title="图形实现"></a>图形实现</h2><p>图形是使用C打出来的，就当练手。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">6</span>;j&gt;i ;j-- ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"    write by binyanbin"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"c:"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后用gcc编译成exe。</p>
<h2 id="cmd_u5FEB_u6377_u65B9_u5F0F"><a href="#cmd_u5FEB_u6377_u65B9_u5F0F" class="headerlink" title="cmd快捷方式"></a>cmd快捷方式</h2><p>新建快捷方式，输入C:\Windows\System32\cmd.exe /k “C:\yanbin\mycmd.exe”。最后为你编译exe的位置。<br><img src="/img/c-2.png" alt="cmd快捷方式"><br>这个cmd快捷方式就是你的个性terminal，当然你也可以打印出更漂亮的图形做你的terminal。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很多牛人有自己的个性化的命令行，为什么我没有呢?晚上我就写了一个。效果如下:<br><img src="/img/c-1.png" alt="效果"><br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言之编译器GCC]]></title>
    <link href="http://binyanbin.github.io/2016/03/23/c-1/"/>
    <id>http://binyanbin.github.io/2016/03/23/c-1/</id>
    <published>2016-03-22T16:00:00.000Z</published>
    <updated>2016-03-25T13:22:02.402Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u662FC"><a href="#u4E3A_u4EC0_u4E48_u662FC" class="headerlink" title="为什么是C"></a>为什么是C</h2><p>很多牛B的开源项目都是C实现的，如redis,nginx,memcache,node等等。主要原因是C语言比较简单(相对C++来说)，编译器稳定可靠。C如果借鉴一些良好设计,C一样可以写的很好，如果习惯了，开发效率未必会比C++低。那么C怎么编译呢?</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC(GNU Compiler Collection)，GNU编译器集合,是一套由 GNU 开发的编程语言编译器。其中包括了ANSI C Compiler。在现在遍地都是IDE的时代，很多开发人员都忘了怎么用cli去编译程序。gcc编译过程是分为四个阶段进行的，即预处理(也称预编译,Preprocessing)、编译(Compilation)、汇编(Assembly)和连接(Linking)。<br><a id="more"></a></p>
<h4 id="u9884_u5904_u7406"><a href="#u9884_u5904_u7406" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。</p>
<h4 id="u7F16_u8BD1"><a href="#u7F16_u8BD1" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码。</p>
<h4 id="u6C47_u7F16"><a href="#u6C47_u7F16" class="headerlink" title="汇编"></a>汇编</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>
<p>汇编器可以将汇编代码编译为目标文件。</p>
<h4 id="u8FDE_u63A5"><a href="#u8FDE_u63A5" class="headerlink" title="连接"></a>连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p>
<h4 id="u7B80_u5355_u7F16_u8BD1"><a href="#u7B80_u5355_u7F16_u8BD1" class="headerlink" title="简单编译"></a>简单编译</h4><p>一步到位:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u591A_u4E2A_u7A0B_u5E8F_u6587_u4EF6_u7684_u7F16_u8BD1"><a href="#u591A_u4E2A_u7A0B_u5E8F_u6587_u4EF6_u7684_u7F16_u8BD1" class="headerlink" title="多个程序文件的编译"></a>多个程序文件的编译</h4><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c <span class="built_in">test</span>1.c -o <span class="built_in">test</span>1.o</span><br><span class="line">gcc -c <span class="built_in">test</span>2.c -o <span class="built_in">test</span>2.o</span><br><span class="line">gcc <span class="built_in">test</span>1.o <span class="built_in">test</span>2.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<h2 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h2><p>同样IDE的开发人员估计一般都不知道，IDE都为你做了这个工作。一个软件的代码文件是非常多的，如果你要自己一个个去写编译规则是相当复杂的。那么makefile就是解决整个软件的编译规则。一个软件项目中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了效率。</p>
<h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>MinGW是指只用自由软件来生成纯粹的Win32可执行文件的编译环境，它是Minimalist GNU on Windows的略称。</p>
<h4 id="u4E0B_u8F7DMinGW"><a href="#u4E0B_u8F7DMinGW" class="headerlink" title="下载MinGW"></a>下载MinGW</h4><p>到Sourceforge(<a href="http://sourceforge.net/project/showfiles.php?group_id=2435)下载一个MinGW.exe。" target="_blank" rel="external">http://sourceforge.net/project/showfiles.php?group_id=2435)下载一个MinGW.exe。</a></p>
<h4 id="u73AF_u5883_u53D8_u91CF_u7684_u914D_u7F6E"><a href="#u73AF_u5883_u53D8_u91CF_u7684_u914D_u7F6E" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h4><p>a.在PATH的值中加入“C:\MinGW\bin”。这是寻找gcc编译器的路径。如果PATH中还有其他内容，需要用英文状态下分号进行分割<br>b.新建LIBRARY_PATH变量，在其值中加入“C:\MinGW\lib”。这是标准库存放的路径。<br>c.新建C_INCLUDE_PATH变量，在其值中加入“C:\MinGW\include”。这是Include查找头文件的路径。</p>
<h4 id="u9A8C_u8BC1gcc_u662F_u5426_u6B63_u5E38_u8FD0_u884C"><a href="#u9A8C_u8BC1gcc_u662F_u5426_u6B63_u5E38_u8FD0_u884C" class="headerlink" title="验证gcc是否正常运行"></a>验证gcc是否正常运行</h4><p>在cmd控制台窗口下面,输入gcc -v.若已经成功安装好,会显示gcc的版本信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u662FC"><a href="#u4E3A_u4EC0_u4E48_u662FC" class="headerlink" title="为什么是C"></a>为什么是C</h2><p>很多牛B的开源项目都是C实现的，如redis,nginx,memcache,node等等。主要原因是C语言比较简单(相对C++来说)，编译器稳定可靠。C如果借鉴一些良好设计,C一样可以写的很好，如果习惯了，开发效率未必会比C++低。那么C怎么编译呢?</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC(GNU Compiler Collection)，GNU编译器集合,是一套由 GNU 开发的编程语言编译器。其中包括了ANSI C Compiler。在现在遍地都是IDE的时代，很多开发人员都忘了怎么用cli去编译程序。gcc编译过程是分为四个阶段进行的，即预处理(也称预编译,Preprocessing)、编译(Compilation)、汇编(Assembly)和连接(Linking)。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript模块化开发]]></title>
    <link href="http://binyanbin.github.io/2016/03/21/javascript-base-4/"/>
    <id>http://binyanbin.github.io/2016/03/21/javascript-base-4/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-03-21T14:25:18.781Z</updated>
    <content type="html"><![CDATA[<p>Javascript不算模块化编程语言，但是web开发需要团队开发和团队协做。现在javascript模块化开发已非常正熟，支持模块化开发的框架非常多。</p>
<h2 id="u539F_u59CB_u5199_u6CD5"><a href="#u539F_u59CB_u5199_u6CD5" class="headerlink" title="原始写法"></a>原始写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只要把不同的函数简单地放在一个文件中，就算是一个模块，通常一个文件一个模块。<br><a id="more"></a></p>
<h2 id="jquery_u65F6_u4EE3"><a href="#jquery_u65F6_u4EE3" class="headerlink" title="jquery时代"></a>jquery时代</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, windows</span>) </span>&#123;</span><br><span class="line">　　　　<span class="comment">//...</span></span><br><span class="line">　　&#125;)(jQuery, windows);</span><br></pre></td></tr></table></figure>
<p>通过立即执行匿名函数来达到封装的作用,如模块内部调用全局变量，则将其输入模块中。</p>
<h2 id="commonjs_u65F6_u4EE3"><a href="#commonjs_u65F6_u4EE3" class="headerlink" title="commonjs时代"></a>commonjs时代</h2><p>commonjs规范是目前JavaScript模块化的事实标准。支持commonjs规范的框架及程序比较多，如node,seajs.规范中最重要的二点:</p>
<ul>
<li>require它是一个函数,引用其它模块使用require。</li>
<li>exports是一个对象，导出模块api使用exports，可供其它模块调用。<br>当然除了这两点还有一些其它细节不一一介绍。下面看一个示例:</li>
</ul>
<p>math.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.add=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>increment.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>program.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inc = <span class="built_in">require</span>(<span class="string">'increment'</span>).increment;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">inc(a);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Javascript不算模块化编程语言，但是web开发需要团队开发和团队协做。现在javascript模块化开发已非常正熟，支持模块化开发的框架非常多。</p>
<h2 id="u539F_u59CB_u5199_u6CD5"><a href="#u539F_u59CB_u5199_u6CD5" class="headerlink" title="原始写法"></a>原始写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只要把不同的函数简单地放在一个文件中，就算是一个模块，通常一个文件一个模块。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[jmeter 基础概念]]></title>
    <link href="http://binyanbin.github.io/2016/03/12/jmeter-1/"/>
    <id>http://binyanbin.github.io/2016/03/12/jmeter-1/</id>
    <published>2016-03-11T16:00:00.000Z</published>
    <updated>2016-03-12T16:53:31.616Z</updated>
    <content type="html"><![CDATA[<p>最近做性能优化工作，同时要给自己的工作给一个总结。需要自己弄性能测试及编写性能测试报告。在别人推荐下使用JMeter对项目进行性能测试。JMeter可以进行配置和执行负载测试、性能测试和压力测试的工具。了解一下几个概念:</p>
<ul>
<li>负载测试: 这类测试使系统或者应用程序在预先设计好的极端场景下测试运行。这类测试用来评估系统或者程序在极端条件下的行为。</li>
<li>性能测试: 这种测试被用来检测系统的性能表现，包括特定情况下，系统的响应能力和稳定性。</li>
<li>压力测试: 这类测试通过载入更多的外部资源，并使系统组件超越其所设定的能力范围,试图使系统挂掉.<a id="more"></a>
JMeter 的安装非常简单,从官方网站上下载，解压之后即可使用。运行命令在%JMETER_HOME%/bin下,对于 Windows用户来说,命令是jmeter.bat。运行前请检查JMeter的文档,查看是否具备相关的运行条件:JDK的版本要求是否满足.<h2 id="Test_Plan_u914D_u7F6E"><a href="#Test_Plan_u914D_u7F6E" class="headerlink" title="Test Plan配置"></a>Test Plan配置</h2><img src="/img/jmeter-1.png" alt="基本配置"><br>进去之后，你会看到Test Plan和WorkBench。这两个块东西没有太多区别，不同的是Test Plan是测试的相关配置，workbench可以帮你创建一个代理服务器帮Test Plan录制测试脚本。<h4 id="ThreadGroup__u7EBF_u7A0B_u7EC4"><a href="#ThreadGroup__u7EBF_u7A0B_u7EC4" class="headerlink" title="ThreadGroup 线程组"></a>ThreadGroup 线程组</h4>一个线程组基本上是不同的测试计划元素的组合，它是一个测试计划的核心，它控制着基本核心参数。<br>为了创建一个测试计划，首先你不得不去创建一个线程组，配置如下参数:线程数量，过渡时期，循环次数和正常情况或者错误情况下的行为：<h4 id="Samplers__u91C7_u6837_u5668"><a href="#Samplers__u91C7_u6837_u5668" class="headerlink" title="Samplers 采样器"></a>Samplers 采样器</h4>采样器用于发送请求到不同类型的服务器。它们是每一个测试计划的基本要素，一切都围绕这些采样器而工作：采样器执行请求，这些请求产生一个或多个响应，后续将被分析。<h4 id="Logic_Controllers__u903B_u8F91_u63A7_u5236_u5668"><a href="#Logic_Controllers__u903B_u8F91_u63A7_u5236_u5668" class="headerlink" title="Logic Controllers 逻辑控制器"></a>Logic Controllers 逻辑控制器</h4>逻辑控制器允许你配置一个线程组内不同采样器的执行顺序。<h4 id="Listeners__u76D1_u542C_u5668"><a href="#Listeners__u76D1_u542C_u5668" class="headerlink" title="Listeners 监听器"></a>Listeners 监听器</h4>监听器提供不同的方式查看由采样器请求产生的结果。监听器以报表、树型结构、或简明的日志文件的形式分析结果。<h4 id="Timers__u5B9A_u65F6_u5668"><a href="#Timers__u5B9A_u65F6_u5668" class="headerlink" title="Timers 定时器"></a>Timers 定时器</h4>定时器来定义请求之间的等待时间。如果不指定，JMeter会一个请求完成后立即执行下一个请求，没有任何等待时间。<h4 id="Assertions__u65AD_u8A00"><a href="#Assertions__u65AD_u8A00" class="headerlink" title="Assertions 断言"></a>Assertions 断言</h4>断言通过验证采样器请求产生的响应，来验证测试计划的有效性。类似于单元测试断言，用来检测被测试应用程序的响应质量。<h4 id="Configuration_nodes__u914D_u7F6E_u8282_u70B9"><a href="#Configuration_nodes__u914D_u7F6E_u8282_u70B9" class="headerlink" title="Configuration nodes 配置节点"></a>Configuration nodes 配置节点</h4>配置节点可以将不同的参数传递给取样器请求。<h4 id="Pre_processors__u524D_u7F6E_u5904_u7406_u5668"><a href="#Pre_processors__u524D_u7F6E_u5904_u7406_u5668" class="headerlink" title="Pre processors 前置处理器"></a>Pre processors 前置处理器</h4>前置处理器在采样器执行前被触发的元素。<h4 id="Post_processors__u540E_u7F6E_u5904_u7406_u5668"><a href="#Post_processors__u540E_u7F6E_u5904_u7406_u5668" class="headerlink" title="Post processors 后置处理器"></a>Post processors 后置处理器</h4>后置处理器是取样器被执行后被触发执行的元素。</li>
</ul>
<h2 id="WorkBench"><a href="#WorkBench" class="headerlink" title="WorkBench"></a>WorkBench</h2><p><img src="/img/jmeter-2.png" alt="非测试元素"><br>WorkBench可以Add三个Non-test Elements:</p>
<ul>
<li>Http Mirror Server 镜像的服务器<br>其实就是一个代理服务器,它把所有接收到的请求原封不动地返回，这样就可以看到发出请求和响应的具体内容了。</li>
<li>Http(s) Test Script Recorder 脚本录制器<br>也是一个代理服务器,它会把所有接受的请求全部记录到Test Plan配置中,你在测试中可以使用这些录制的脚本。</li>
</ul>
<h2 id="u6D4B_u8BD5_u8BA1_u5212_u5143_u7D20_u6267_u884C_u987A_u5E8F"><a href="#u6D4B_u8BD5_u8BA1_u5212_u5143_u7D20_u6267_u884C_u987A_u5E8F" class="headerlink" title="测试计划元素执行顺序"></a>测试计划元素执行顺序</h2><ul>
<li>配置节点</li>
<li>前置处理器</li>
<li>定时器</li>
<li>取样器</li>
<li>后置处理器（只在有结果可用情况下执行）</li>
<li>断言（只在有结果可用情况下执行）</li>
<li>监听器（只在有结果可用情况下执行）</li>
</ul>
<h2 id="u6027_u80FD_u6307_u6807"><a href="#u6027_u80FD_u6307_u6807" class="headerlink" title="性能指标"></a>性能指标</h2><ul>
<li>Label:定义的HTTP请求名称</li>
<li>Samples:表示这次测试中一共发出了多少个请求</li>
<li>Average:访问页面的平均响应时间 </li>
<li>Min:访问页面的最小响应时间</li>
<li>Max:访问页面的最大响应时间</li>
<li>Error%:错误的请求的数量/请求的总数</li>
<li>Throughpu:每秒完成的请求数</li>
<li>KB/Sec:每秒从服务器端接收到的数据量</li>
<li>Median:50％的用户响应时间</li>
<li>90%Line:90％的用户响应时间</li>
<li>95%Line:95％的用户响应时间</li>
<li>99%Line:99％的用户响应时间<br>时间指标的单位都是毫秒。</li>
</ul>
<h2 id="u7B2C_u4E00_u4E2Aweb_u6027_u80FD_u6D4B_u8BD5"><a href="#u7B2C_u4E00_u4E2Aweb_u6027_u80FD_u6D4B_u8BD5" class="headerlink" title="第一个web性能测试"></a>第一个web性能测试</h2><p>我做了一个博客网站首页的性能测试，只设置ThreadGroup,Sampler,Listener三项就可以运行。</p>
<h4 id="ThreadGroup_u8BBE_u7F6E"><a href="#ThreadGroup_u8BBE_u7F6E" class="headerlink" title="ThreadGroup设置"></a>ThreadGroup设置</h4><p>一个性能测试请求负载是基于一个线程组完成的，jmeter中每个测试计划至少需要包含一个线程组。Test Plan右键菜单可新增ThreadGroup(add-&gt;Threads-&gt;ThreadGroup);<br><img src="/img/jmeter-3.png" alt="ThreadGroup"></p>
<ul>
<li>Number of Threads 线程数:虚拟用户数.一个虚拟用户占用一个进程或线程。</li>
<li>Ramp-up Period 准备时长:设置的虚拟用户数需要多长时间全部启动。</li>
<li>Loop Count 循环次数：每个线程发送请求的次数。</li>
</ul>
<h4 id="Sample_u8BBE_u7F6E"><a href="#Sample_u8BBE_u7F6E" class="headerlink" title="Sample设置"></a>Sample设置</h4><p>在ThreadGroup上右键菜单可新增HttpRequest（add-&gt;Sampler-&gt;HttpRequest).Sampler是与服务器进行交互的单元.一个Sampler通常进行三部分的工作：</p>
<ul>
<li>向服务器发送请求</li>
<li>记录服务器的响应数据</li>
<li>记录相应时间信息<br><img src="/img/jmeter-4.png" alt="HttpRequest"></li>
</ul>
<h4 id="Listener_u8BBE_u7F6E"><a href="#Listener_u8BBE_u7F6E" class="headerlink" title="Listener设置"></a>Listener设置</h4><p>脚本的主要部分设置完成后,需要通过某种方式获得性能测试中的测试结果。ThreadGroup上右键菜单可新增Listner（add-&gt;Listener-&gt;Aggregate Report).<br><img src="/img/jmeter-5.png" alt="HttpRequest"><br>我最关心的是我的博客响应时间，数据显示客户的平均响应时间为:337毫秒,99%的用户在1985毫秒内完成，也就不超2秒。最少用户响应时间为149毫秒，最大用户响应时间为5020毫秒</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近做性能优化工作，同时要给自己的工作给一个总结。需要自己弄性能测试及编写性能测试报告。在别人推荐下使用JMeter对项目进行性能测试。JMeter可以进行配置和执行负载测试、性能测试和压力测试的工具。了解一下几个概念:</p>
<ul>
<li>负载测试: 这类测试使系统或者应用程序在预先设计好的极端场景下测试运行。这类测试用来评估系统或者程序在极端条件下的行为。</li>
<li>性能测试: 这种测试被用来检测系统的性能表现，包括特定情况下，系统的响应能力和稳定性。</li>
<li>压力测试: 这类测试通过载入更多的外部资源，并使系统组件超越其所设定的能力范围,试图使系统挂掉.]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习8  Sentinel集群控制]]></title>
    <link href="http://binyanbin.github.io/2016/03/10/redis-8/"/>
    <id>http://binyanbin.github.io/2016/03/10/redis-8/</id>
    <published>2016-03-09T16:00:00.000Z</published>
    <updated>2016-03-10T15:53:20.146Z</updated>
    <content type="html"><![CDATA[<p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。<br><a id="more"></a></p>
<h2 id="Sentinel_u4EFB_u52A1"><a href="#Sentinel_u4EFB_u52A1" class="headerlink" title="Sentinel任务"></a>Sentinel任务</h2><ul>
<li>监控:Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒:当被监控的某个Redis服务器出现问题时,Sentinel 可以通过API向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移:当一个主服务器不能正常工作时,Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器, 并让失效主服务器的其他从服务器改为复制新的主服务器;当客户端试图连接失效的主服务器时,集群也会向客户端返回新主服务器的地址,使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<h2 id="u914D_u7F6ESentinel"><a href="#u914D_u7F6ESentinel" class="headerlink" title="配置Sentinel"></a>配置Sentinel</h2><p>下面是一个Sentinel的标准配置<br>port 26370<br>sentinel monitor master 127.0.0.1 6381 1<br>sentinel auth-pass master yanbin<br>sentinel down-after-milliseconds master 60000<br>sentinel parallel-syncs master 5<br>第一行配置指示Sentinel去监视一个名为master的主服务器,将这个主服务器判断为失效至少需要1个Sentinel同意。只要同意Sentinel的数量不达标,自动故障迁移就不会执行。<br>down-after-milliseconds 指定了Sentinel认为服务器已经断线所需的毫秒数。<br>parallel-syncs 执行故障转移时,最多可以有多少个从服务器同时对新的主服务器进行同步,数字越小,完成故障转移所需的时间就越长。<br>auth-pass 监视主服务器的密码。</p>
<h2 id="u8FD0_u884CSentinel"><a href="#u8FD0_u884CSentinel" class="headerlink" title="运行Sentinel"></a>运行Sentinel</h2><p>Sentinel配置在我这个windows 2.8这个版本中是没有的，我自建了一个sentinel.conf配置文件。然后使用命令行启动Sentinel：<br>redis-server  sentinel.conf –sentinel</p>
<h2 id="u6545_u969C_u6F14_u793A"><a href="#u6545_u969C_u6F14_u793A" class="headerlink" title="故障演示"></a>故障演示</h2><p>集群配置最少需要启动三个服务，我启动了4个服务分别是<br>127.0.0.1:26370 （redis sentinel 集群监控）<br>127.0.0.1:6379  （redis 主）<br>127.0.0.1:6380  （redis 从）<br>127.0.0.1:6381  （redis 从）<br>查看网络状态</p>
<pre><code class="bash">$ redis-cli -h 127.0.0.1 -p 26380 info Sentinel
Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
master0:name=master,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=1
</code></pre>
<p>接着我关闭一个服务</p>
<pre><code class="bash">redis-cli -h 127.0.0.1 -p 6379 shutdow
</code></pre>
<p>过了一会再次查看网络</p>
<pre><code class="bash">$ redis-cli -h 127.0.0.1 -p 26380 info Sentinel
<span class="comment">#Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
master0:name=master,status=ok,address=127.0.0.1:6381,slaves=1,sentinels=1
</code></pre>
<p>6381变成主redis,可以write操作。<br>再次启动6379</p>
<pre><code class="bash">$ redis-cli -h 127.0.0.1 -p 26380 info Sentinel
<span class="comment">#Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
master0:name=master,status=ok,address=127.0.0.1:6381,slaves=2,sentinels=1
</code></pre>
<p>6379已不是主redis，变成了从redis,不能再write操作，只能read.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习7 主从复制]]></title>
    <link href="http://binyanbin.github.io/2016/03/09/redis-7/"/>
    <id>http://binyanbin.github.io/2016/03/09/redis-7/</id>
    <published>2016-03-08T16:00:00.000Z</published>
    <updated>2016-03-09T14:52:32.154Z</updated>
    <content type="html"><![CDATA[<p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。<a id="more"></a>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2></li>
<li>把安装好的redis做master,然后copy一份当slave。然后修改slave配置<br>port 6379  修改为port 6380<br>slaveof 127.0.0.1 6379  (映射到主服务器上)</li>
<li>配置完成以后可以在二个服务中分别进行set和get操作来看效果,master可以get和set操作,slave上能get操作不能set，也就是说master可读可写，slave只能读。你在master上set数据，slave上可以查询得到。</li>
<li>在master和slave分别执行info命令，查看结果如下：<br><img src="/img/info1.png" alt="master"><br><img src="/img/info2.png" alt="slave"></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习6 持久化]]></title>
    <link href="http://binyanbin.github.io/2016/03/08/redis-6/"/>
    <id>http://binyanbin.github.io/2016/03/08/redis-6/</id>
    <published>2016-03-07T16:00:00.000Z</published>
    <updated>2016-03-07T14:17:00.704Z</updated>
    <content type="html"><![CDATA[<p>redis提供二种持久化方式:一种是RDB,另一种是AOF.<br>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br><a id="more"></a></p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><ul>
<li>rdb配置<br>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集:<br>save 60 1000</li>
<li>aof配置<br>appendonly yes  启用<br>appendfsync always 每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全<br>appendfsync everysec 每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。<br>appendfsync no 从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。<br>配置好，启动服务之后，在你程序的目录会出现二个文件，一个是dump.rdb,一个是appendonly.aof</li>
<li>RDB和AOF 之间的相互作用</li>
</ul>
<ol>
<li>当 Redis 启动时，如果RDB持久化和AOF持久化都被打开了，那么程序会优先使用 AOF 文件来恢复数据集，因为 AOF 文件所保存的数据通常是最完整的。</li>
<li>Redis为了防止两个后台(RDB和AOF)进程同时对磁盘进行大量的 I/O 操作。redis在RDB Save的过程中，不会执行 AOF RewriteAOF。反之,在AOF RewriteAOF执行的过程中，也不会执行RDB Save。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis提供二种持久化方式:一种是RDB,另一种是AOF.<br>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习5 lua脚本]]></title>
    <link href="http://binyanbin.github.io/2016/03/07/redis-5/"/>
    <id>http://binyanbin.github.io/2016/03/07/redis-5/</id>
    <published>2016-03-06T16:00:00.000Z</published>
    <updated>2016-03-07T14:19:29.124Z</updated>
    <content type="html"><![CDATA[<p>redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处:</p>
<ul>
<li>减少网络开销:批量执行redis命令。</li>
<li>原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。</li>
<li>复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。<a id="more"></a>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2></li>
<li>lua脚本<br>lua是一个很容易嵌入其它语言中使用的语言。很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。查看<a href="http://manual.luaer.cn/" target="_blank" rel="external">lua5.1在线中文用户手册</a>。</li>
<li>Eval<br>通过redis-cli客户端单独调用Lua脚本文件，格式如下:<br>redis-cli –eval myscript.lua [key …] arg [arg …]<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ </span><br><span class="line">限制一定时间内的调用次数 </span><br><span class="line">KEYS[1]:key </span><br><span class="line">ARGV[1]:存在时长</span><br><span class="line">ARGV[2]:调用次数</span><br><span class="line">]]</span></span><br><span class="line"><span class="keyword">local</span> times = redis.call(<span class="string">'incr'</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">'expire'</span>,KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>调用 redis-cli –eval d:\test.lua test:127.0.0.1 , 10 3</p>
<p>通过EVAL命令执行脚本，格式如下:<br>EVAL script numkeys key [key …] arg [arg …]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">eval</span> <span class="string">"local times = redis.call('incr',KEYS[1]);if times == 1 then redis.call('expire',KEYS[1], ARGV[1]);end;if times &gt; tonumber(ARGV[2]) then return 0;end;return 1"</span> <span class="number">1</span> <span class="built_in">test</span>:<span class="number">127.0</span>.<span class="number">0.1</span> , <span class="number">10</span> <span class="number">3</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get <span class="built_in">test</span>:<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<p>redis.call lua脚本通过redis.call调用redis命令。</p>
<p> 总结:我们可以通过Lua来实现很多功功能:用Lua来封装复杂了Redis操作的业务;计数，统计，分析，收集数据;实现业务操作事务控制等等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处:</p>
<ul>
<li>减少网络开销:批量执行redis命令。</li>
<li>原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。</li>
<li>复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习4 事务]]></title>
    <link href="http://binyanbin.github.io/2016/03/05/redis-4/"/>
    <id>http://binyanbin.github.io/2016/03/05/redis-4/</id>
    <published>2016-03-04T16:00:00.000Z</published>
    <updated>2016-03-05T17:14:58.831Z</updated>
    <content type="html"><![CDATA[<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<a id="more"></a>
<h2 id="u547D_u4EE4"><a href="#u547D_u4EE4" class="headerlink" title="命令"></a>命令</h2></li>
<li>multi 开启事务</li>
<li>discard 放弃事务</li>
<li>WATCH 事务执行条件</li>
<li>事务执行</li>
</ul>
<p>简单事务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<p>放弃事务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;discard</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p>
<p>事务条件:WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;watch yanbin</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;incr yanbin</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习3 数据类型]]></title>
    <link href="http://binyanbin.github.io/2016/03/03/redis-3/"/>
    <id>http://binyanbin.github.io/2016/03/03/redis-3/</id>
    <published>2016-03-02T16:00:00.000Z</published>
    <updated>2016-03-03T15:35:14.699Z</updated>
    <content type="html"><![CDATA[<p>redis数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hashes</li>
<li>Sets</li>
<li>Sorted sets<a id="more"></a>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2>存值取值:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;GET yanbin</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查询是否存在及删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;exists yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>设置失效时间及查询失效剩余时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire yanbin <span class="number">500</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;tll yanbin </span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">495</span></span><br></pre></td></tr></table></figure></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表是简单的字符串列表，可以排序插入顺序,可以在头部或列表的尾部Redis的列表添加元素。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;rpush yanbin a b c</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lpush yanbin <span class="number">1</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lrange <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lpop yanbin</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;rpop yanbin</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lrange <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;llen yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h2><p>哈希值是字符串字段和字符串值之间的映射，可以表示对象的数据类型。<br>其实实际应用中用json格式做数据保存，可以表示对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hmset user:<span class="number">1000</span> username antirez birthyear <span class="number">1977</span> verified <span class="number">1</span></span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hget user:<span class="number">1000</span> username</span><br><span class="line"><span class="string">"antirez"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hhgetall user:<span class="number">1000</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"username"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"antirez"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"birthyear"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"1977"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"verified"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>集合是一个无序的字符串合集,且不允许重复的成员。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;sadd yanbin <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;smembers yanbin</span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;scard yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Sorted_sets"><a href="#Sorted_sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h2><p>有序集合是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zadd yanbin <span class="number">1</span> a <span class="number">2</span> b <span class="number">3</span> c</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zrange yanbin <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zrange yanbin <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zcard yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hashes</li>
<li>Sets</li>
<li>Sorted sets]]>
    
    </summary>
    
  </entry>
  
</feed>
