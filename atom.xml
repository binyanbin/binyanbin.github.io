<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[码工严彬]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://binyanbin.github.io/"/>
  <updated>2016-03-09T14:52:32.154Z</updated>
  <id>http://binyanbin.github.io/</id>
  
  <author>
    <name><![CDATA[严彬]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[redis学习7 主从复制]]></title>
    <link href="http://binyanbin.github.io/2016/03/09/redis-7/"/>
    <id>http://binyanbin.github.io/2016/03/09/redis-7/</id>
    <published>2016-03-08T16:00:00.000Z</published>
    <updated>2016-03-09T14:52:32.154Z</updated>
    <content type="html"><![CDATA[<p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。<a id="more"></a>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2></li>
<li>把安装好的redis做master,然后copy一份当slave。然后修改slave配置<br>port 6379  修改为port 6380<br>slaveof 127.0.0.1 6379  (映射到主服务器上)</li>
<li>配置完成以后可以在二个服务中分别进行set和get操作来看效果,master可以get和set操作,slave上能get操作不能set，也就是说master可读可写，slave只能读。你在master上set数据，slave上可以查询得到。</li>
<li>在master和slave分别执行info命令，查看结果如下：<br><img src="/img/info1.png" alt="master"><br><img src="/img/info2.png" alt="slave"></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis集群有二种方式，一种分区，一种主从复制。<br>redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。下面是关于redis主从复制的一些特点：</p>
<ul>
<li>master可以有多个slave</li>
<li>除了多个slave连到相同的master外，slave也可以连接其他slave形成图状结构</li>
<li>主从复制不会阻塞master。也就是说当一个或多个slave与master进行初次同步数据时，master可以继续处理client发来的请求。相反slave在初次同步数据时则会阻塞不能处理client的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个slave专门用于client的读请求，比如sort操作可以使用slave来处理。也可以用来做简单的数据冗余<br>*可以在master禁用数据持久化，只需要注释掉master配置文件中的所有save配置，然后只在slave上配置数据持久化。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习6 持久化]]></title>
    <link href="http://binyanbin.github.io/2016/03/08/redis-6/"/>
    <id>http://binyanbin.github.io/2016/03/08/redis-6/</id>
    <published>2016-03-07T16:00:00.000Z</published>
    <updated>2016-03-07T14:17:00.704Z</updated>
    <content type="html"><![CDATA[<p>redis提供二种持久化方式:一种是RDB,另一种是AOF.<br>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br><a id="more"></a></p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><ul>
<li>rdb配置<br>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集:<br>save 60 1000</li>
<li>aof配置<br>appendonly yes  启用<br>appendfsync always 每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全<br>appendfsync everysec 每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。<br>appendfsync no 从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。<br>配置好，启动服务之后，在你程序的目录会出现二个文件，一个是dump.rdb,一个是appendonly.aof</li>
<li>RDB和AOF 之间的相互作用</li>
</ul>
<ol>
<li>当 Redis 启动时，如果RDB持久化和AOF持久化都被打开了，那么程序会优先使用 AOF 文件来恢复数据集，因为 AOF 文件所保存的数据通常是最完整的。</li>
<li>Redis为了防止两个后台(RDB和AOF)进程同时对磁盘进行大量的 I/O 操作。redis在RDB Save的过程中，不会执行 AOF RewriteAOF。反之,在AOF RewriteAOF执行的过程中，也不会执行RDB Save。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis提供二种持久化方式:一种是RDB,另一种是AOF.<br>RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br>AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习5 lua脚本]]></title>
    <link href="http://binyanbin.github.io/2016/03/07/redis-5/"/>
    <id>http://binyanbin.github.io/2016/03/07/redis-5/</id>
    <published>2016-03-06T16:00:00.000Z</published>
    <updated>2016-03-07T14:19:29.124Z</updated>
    <content type="html"><![CDATA[<p>redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处:</p>
<ul>
<li>减少网络开销:批量执行redis命令。</li>
<li>原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。</li>
<li>复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。<a id="more"></a>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2></li>
<li>lua脚本<br>lua是一个很容易嵌入其它语言中使用的语言。很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。查看<a href="http://manual.luaer.cn/" target="_blank" rel="external">lua5.1在线中文用户手册</a>。</li>
<li>Eval<br>通过redis-cli客户端单独调用Lua脚本文件，格式如下:<br>redis-cli –eval myscript.lua [key …] arg [arg …]<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ </span><br><span class="line">限制一定时间内的调用次数 </span><br><span class="line">KEYS[1]:key </span><br><span class="line">ARGV[1]:存在时长</span><br><span class="line">ARGV[2]:调用次数</span><br><span class="line">]]</span></span><br><span class="line"><span class="keyword">local</span> times = redis.call(<span class="string">'incr'</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">'expire'</span>,KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>调用 redis-cli –eval d:\test.lua test:127.0.0.1 , 10 3</p>
<p>通过EVAL命令执行脚本，格式如下:<br>EVAL script numkeys key [key …] arg [arg …]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">eval</span> <span class="string">"local times = redis.call('incr',KEYS[1]);if times == 1 then redis.call('expire',KEYS[1], ARGV[1]);end;if times &gt; tonumber(ARGV[2]) then return 0;end;return 1"</span> <span class="number">1</span> <span class="built_in">test</span>:<span class="number">127.0</span>.<span class="number">0.1</span> , <span class="number">10</span> <span class="number">3</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get <span class="built_in">test</span>:<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<p>redis.call lua脚本通过redis.call调用redis命令。</p>
<p> 总结:我们可以通过Lua来实现很多功功能:用Lua来封装复杂了Redis操作的业务;计数，统计，分析，收集数据;实现业务操作事务控制等等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处:</p>
<ul>
<li>减少网络开销:批量执行redis命令。</li>
<li>原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。</li>
<li>复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习4 事务]]></title>
    <link href="http://binyanbin.github.io/2016/03/05/redis-4/"/>
    <id>http://binyanbin.github.io/2016/03/05/redis-4/</id>
    <published>2016-03-04T16:00:00.000Z</published>
    <updated>2016-03-05T17:14:58.831Z</updated>
    <content type="html"><![CDATA[<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<a id="more"></a>
<h2 id="u547D_u4EE4"><a href="#u547D_u4EE4" class="headerlink" title="命令"></a>命令</h2></li>
<li>multi 开启事务</li>
<li>discard 放弃事务</li>
<li>WATCH 事务执行条件</li>
<li>事务执行</li>
</ul>
<p>简单事务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<p>放弃事务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;discard</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p>
<p>事务条件:WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;watch yanbin</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">set</span> yanbin <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;incr yanbin</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;<span class="built_in">exec</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;get yanbin</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习3 数据类型]]></title>
    <link href="http://binyanbin.github.io/2016/03/03/redis-3/"/>
    <id>http://binyanbin.github.io/2016/03/03/redis-3/</id>
    <published>2016-03-02T16:00:00.000Z</published>
    <updated>2016-03-03T15:35:14.699Z</updated>
    <content type="html"><![CDATA[<p>redis数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hashes</li>
<li>Sets</li>
<li>Sorted sets<a id="more"></a>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2>存值取值:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;GET yanbin</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查询是否存在及删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;exists yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>设置失效时间及查询失效剩余时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;SET yanbin redis</span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire yanbin <span class="number">500</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;tll yanbin </span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">495</span></span><br></pre></td></tr></table></figure></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表是简单的字符串列表，可以排序插入顺序,可以在头部或列表的尾部Redis的列表添加元素。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;rpush yanbin a b c</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lpush yanbin <span class="number">1</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lrange <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lpop yanbin</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;rpop yanbin</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;lrange <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;llen yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h2><p>哈希值是字符串字段和字符串值之间的映射，可以表示对象的数据类型。<br>其实实际应用中用json格式做数据保存，可以表示对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hmset user:<span class="number">1000</span> username antirez birthyear <span class="number">1977</span> verified <span class="number">1</span></span><br><span class="line">ok</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hget user:<span class="number">1000</span> username</span><br><span class="line"><span class="string">"antirez"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;hhgetall user:<span class="number">1000</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"username"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"antirez"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"birthyear"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"1977"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"verified"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>集合是一个无序的字符串合集,且不允许重复的成员。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;sadd yanbin <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;smembers yanbin</span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;scard yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Sorted_sets"><a href="#Sorted_sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h2><p>有序集合是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zadd yanbin <span class="number">1</span> a <span class="number">2</span> b <span class="number">3</span> c</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zrange yanbin <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zrange yanbin <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>)<span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"c"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;zcard yanbin</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>redis数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hashes</li>
<li>Sets</li>
<li>Sorted sets]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习2 Pub/Sub]]></title>
    <link href="http://binyanbin.github.io/2016/03/02/redis-2/"/>
    <id>http://binyanbin.github.io/2016/03/02/redis-2/</id>
    <published>2016-03-01T16:00:00.000Z</published>
    <updated>2016-03-03T15:34:59.504Z</updated>
    <content type="html"><![CDATA[<p>Pub/Sub功能（means Publish,Subscribe）即发布及订阅功能.在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这让我想到了一种模式:观察者模式。定义了一种一对多的依赖关系，让多个观察者对象同时监听某一发布者（主题对象或目标对象），在发布者的状态发生变化时，会通知所有观察者对象。<br>常见的应用场景:构建实时消息系统，比如普通的即时聊天，群聊等功能。消息队列功能.<br><a id="more"></a></p>
<h2 id="Redis-cli"><a href="#Redis-cli" class="headerlink" title="Redis-cli"></a>Redis-cli</h2><ul>
<li>PSUBSCRIBE</li>
<li>PUBLISH</li>
<li>PUNSUBSCRIBE</li>
<li>SUBSCRIBE</li>
<li>UNSUBSCRIBE</li>
</ul>
<h3 id="u4E00_u4E2A_u5BA2_u6237_u7AEF_u8FDB_u884C_u8BA2_u9605_u64CD_u4F5C_28SUBSCRIBE_29_u3002"><a href="#u4E00_u4E2A_u5BA2_u6237_u7AEF_u8FDB_u884C_u8BA2_u9605_u64CD_u4F5C_28SUBSCRIBE_29_u3002" class="headerlink" title="一个客户端进行订阅操作(SUBSCRIBE)。"></a>一个客户端进行订阅操作(SUBSCRIBE)。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;subscribe first second</span><br><span class="line">Reading messages....</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"second"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>订阅first及second两个频道。</p>
<h3 id="u53E6_u4E00_u4E2A_u5BA2_u6237_u7AEF_u53D1_u5E03_u8BA2_u9605_u6D88_u606F_28PUBLISH_29_3A"><a href="#u53E6_u4E00_u4E2A_u5BA2_u6237_u7AEF_u53D1_u5E03_u8BA2_u9605_u6D88_u606F_28PUBLISH_29_3A" class="headerlink" title="另一个客户端发布订阅消息(PUBLISH):"></a>另一个客户端发布订阅消息(PUBLISH):</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;publish first <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>订阅客户端收到消息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;subscribe first second</span><br><span class="line">Reading messages....</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"second"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"1"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u9000_u8BA2_28UNSUBSCRIBE_29"><a href="#u9000_u8BA2_28UNSUBSCRIBE_29" class="headerlink" title="退订(UNSUBSCRIBE)"></a>退订(UNSUBSCRIBE)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;unsubsribe  first </span><br><span class="line">Reading messages....</span><br><span class="line"><span class="number">1</span>) <span class="string">"unsubsribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">3</span>) (<span class="built_in">integer</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="u6309_u6A21_u5F0F_u8BA2_u9605_u548C_u9000_u8BA2_28PSUBSCRIBE_u548CPUNSUBSCRIBE_29"><a href="#u6309_u6A21_u5F0F_u8BA2_u9605_u548C_u9000_u8BA2_28PSUBSCRIBE_u548CPUNSUBSCRIBE_29" class="headerlink" title="按模式订阅和退订(PSUBSCRIBE和PUNSUBSCRIBE)"></a>按模式订阅和退订(PSUBSCRIBE和PUNSUBSCRIBE)</h3><p>每个模式以 <em> 作为匹配符，比如 it</em> 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)。 news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Pub/Sub功能（means Publish,Subscribe）即发布及订阅功能.在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这让我想到了一种模式:观察者模式。定义了一种一对多的依赖关系，让多个观察者对象同时监听某一发布者（主题对象或目标对象），在发布者的状态发生变化时，会通知所有观察者对象。<br>常见的应用场景:构建实时消息系统，比如普通的即时聊天，群聊等功能。消息队列功能.<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis学习1 环境及配置]]></title>
    <link href="http://binyanbin.github.io/2016/02/28/redis-1/"/>
    <id>http://binyanbin.github.io/2016/02/28/redis-1/</id>
    <published>2016-02-27T16:00:00.000Z</published>
    <updated>2016-03-09T14:51:42.420Z</updated>
    <content type="html"><![CDATA[<p>最近工作需要使用redis，现在只能边学习边总结。Redis的介绍就不说了，网上一搜一大把。</p>
<h2 id="u73AF_u5883_u642D_u5EFA"><a href="#u73AF_u5883_u642D_u5EFA" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官方不提供windows版redis，<a href="https://github.com/MSOpenTech" target="_blank" rel="external">微软开源技术的github</a>上有提供，可以<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="external">下载</a>。下载解决之后，我们就开始可以搭建开发环境。<br><a id="more"></a></p>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><ul>
<li>maxheap<br>这个是一个强限制，maxheap的大小包括文件存储大小及内存存储大小。如果超过这个限制，服务就会结束。</li>
<li>maxmemory<br>maxheap必需要比maxmemory大，一般设置为maxmemory的1.5倍。</li>
<li>文件系统大小<br>redis官方提供的公式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(size of physical memory) + (2 * size of maxheap)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果你有一台机器内存为8G,maxheap设置为8G，那么你至少要有这么多空闲硬盘空间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(8GB) + (2 * 8GB) = 24GB</span><br></pre></td></tr></table></figure></p>
<ul>
<li>maxmemory-policy<br>如果运行中达到了maxmemory，redis将根据这个设置清除一些存储数据。</li>
<li>requirepass<br>设置服务密码。</li>
<li>heapdir<br>内存映射文件路径</li>
<li>timeout<br>连接超时时间</li>
</ul>
<h3 id="u8FD0_u884C"><a href="#u8FD0_u884C" class="headerlink" title="运行"></a>运行</h3><p>启动服务<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.windows.conf</span><br></pre></td></tr></table></figure></p>
<p>启动客户端<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -p <span class="number">6379</span> -a password</span><br></pre></td></tr></table></figure></p>
<h3 id="u57FA_u672C_u547D_u4EE4"><a href="#u57FA_u672C_u547D_u4EE4" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> key value </span><br><span class="line">get key</span><br><span class="line"><span class="winutils">del</span> key</span><br><span class="line">exists key</span><br><span class="line">expire key <span class="number">100</span></span><br><span class="line">keys *</span><br><span class="line">db size</span><br><span class="line">ttl key</span><br><span class="line">info</span><br><span class="line">flushdb </span><br><span class="line"><span class="winutils">ping</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近工作需要使用redis，现在只能边学习边总结。Redis的介绍就不说了，网上一搜一大把。</p>
<h2 id="u73AF_u5883_u642D_u5EFA"><a href="#u73AF_u5883_u642D_u5EFA" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官方不提供windows版redis，<a href="https://github.com/MSOpenTech">微软开源技术的github</a>上有提供，可以<a href="https://github.com/MSOpenTech/redis/releases">下载</a>。下载解决之后，我们就开始可以搭建开发环境。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[并发情况下锁的使用]]></title>
    <link href="http://binyanbin.github.io/2016/02/26/lock/"/>
    <id>http://binyanbin.github.io/2016/02/26/lock/</id>
    <published>2016-02-25T16:00:00.000Z</published>
    <updated>2016-02-27T16:12:34.744Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://binyanbin.github.io/2016/02/18/interview-hishop/">电商面试题</a>中，我使用了锁来控制并发时的缓存使用。为什么要加锁，因为在并发环境下，一个线程正在修改缓存，另一个线程在读缓存时，缓存数据很可能会被破坏;另外，使用锁可以控制超卖现像。下面我介绍常用的二种锁：读写锁和互斥锁。<br><a id="more"></a></p>
<h1 id="u8BFB_u5199_u9501"><a href="#u8BFB_u5199_u9501" class="headerlink" title="读写锁"></a>读写锁</h1><p>缓存一般使用的情况应该是:</p>
<ul>
<li>只能由一个线程写，但可以多个线程读。</li>
<li>在读操作时，不能同时让其它线程写，在写操作时，不能同时读。</li>
</ul>
<p>实现以上两种情况的锁称读写锁，读写锁有两种模式。</p>
<ul>
<li>读模式:可以有多个线程同时占有。</li>
<li>写模式:一次只有一个线程可以占有。</li>
</ul>
<h1 id="u4E92_u65A5_u9501"><a href="#u4E92_u65A5_u9501" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>在我面试题的代码中所有操作使用的是互斥锁，即保证lock上的代码同一时刻只被一个线程操作。这么做可以保证在任意时刻只有单个线程访问缓存，做到线程安全，但是这种方式效率并不高。原因如下:</p>
<ul>
<li>降低读的并发性，降低了系统使用效率。</li>
<li>像限时抢购、秒杀这种高并发场景，应该要支持对不同的抢购商品并发下单，提高下单效率。</li>
</ul>
<h1 id="u9650_u65F6_u62A2_u8D2D_u3001_u79D2_u6740_u5E76_u53D1_u573A_u666F_u7684_u5E94_u7528"><a href="#u9650_u65F6_u62A2_u8D2D_u3001_u79D2_u6740_u5E76_u53D1_u573A_u666F_u7684_u5E94_u7528" class="headerlink" title="限时抢购、秒杀并发场景的应用"></a>限时抢购、秒杀并发场景的应用</h1><p>1.应为每个商品订单缓存建一个读写锁。<br>2.在对商品下单时，应该对该商品加上写模式锁，保证该商品同一时刻只有一个用户下单，不会引起商品超卖。<br>3.获取订单缓存数据时，应为该商品加上读模式锁，保证其它线程也可以读到缓存订单数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://binyanbin.github.io/2016/02/18/interview-hishop/">电商面试题</a>中，我使用了锁来控制并发时的缓存使用。为什么要加锁，因为在并发环境下，一个线程正在修改缓存，另一个线程在读缓存时，缓存数据很可能会被破坏;另外，使用锁可以控制超卖现像。下面我介绍常用的二种锁：读写锁和互斥锁。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一家公司的8年技术总结]]></title>
    <link href="http://binyanbin.github.io/2016/02/23/8year-review/"/>
    <id>http://binyanbin.github.io/2016/02/23/8year-review/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-02-23T17:10:37.294Z</updated>
    <content type="html"><![CDATA[<p>今天离职手续终于办完了，顺便回顾一下公司这几年研发技术的发展。</p>
<h2 id="asp-net_webform"><a href="#asp-net_webform" class="headerlink" title="asp.net webform"></a>asp.net webform</h2><p>我刚进公司那会，公司的所有项目基本上都是按照微软的petshop来做的，页面采用webform。当时还是觉得很牛B。当时也不知道什么前后端，所有代码全由后端开发人员包办，从数据库到界面，美工把css写好，开发人员只要在控件中指定css中的class,就可以实现效果，这种方式上手简单，开发快速。缺点就不叙述了，总结一点，只合适做特定项目。<br><img src="/img/1.png" alt="webform"></p>
<h2 id="asp-net_mvc"><a href="#asp-net_mvc" class="headerlink" title="asp.net mvc"></a>asp.net mvc</h2><p>大概在2009年左右，我去参加微软技术大会，当时微软推asp.net mvc。回来之后建议公司采用了asp.net mvc方式开发项目，在此终于有一点前后端的概念了，当然对开发人员要求也高了一些，再没有无所不能的控件使用了，但是更灵活。这时候需要美工做好静态页面，静态页面中还需要包括交互效果，开发人员按照静态页面用服务端模板语言生成。但是09年那次的使用并不成功，1.开发人员要求高，2.当年的版本并不成熟。<br><img src="/img/2.png" alt="mvc"></p>
<h2 id="asp-net_webapi_+__u524D_u7AEFmvc_u7684_u624B_u673A_u5F00_u53D1_u6A21_u5F0F"><a href="#asp-net_webapi_+__u524D_u7AEFmvc_u7684_u624B_u673A_u5F00_u53D1_u6A21_u5F0F" class="headerlink" title="asp.net webapi + 前端mvc的手机开发模式"></a>asp.net webapi + 前端mvc的手机开发模式</h2><p>从12年公司开始做手机,由于原生开发成本太高，最后采用hybrid开发模式，最终使用开源项目cordova来开发手机app，前后端彻底分开，前端的静态页面直接放到手机中，通过ajax调用webapi中取数据，再把数据绑到前端模板上进行界面渲染。这是美工只需要做图或静态界面，不需要实现界面交互，界面交互、服务端交互、手机交互全由前端开发完成，前端开发还需要定义webapi的接口，后端开发只管实现webapi接口，能满足前端所需要的数据要求。这种以前端为主导的开发模式，对前端开发人员要求更高，但是为公司培养了一堆优秀的前端开发人员。<br><img src="/img/3.png" alt="webapi"></p>
<h2 id="u5927_u524D_u7AEF_28_u5168_u6808_29_u5F00_u53D1"><a href="#u5927_u524D_u7AEF_28_u5168_u6808_29_u5F00_u53D1" class="headerlink" title="大前端(全栈)开发"></a>大前端(全栈)开发</h2><p>本来想使用此模式尝试做web开发，由前端完成从界面到路由，从登陆到权限，以及session,cookie等进行完全控制，后端专注于业务及数据，按照做手机开发模式那样，给前端开发更大的空间。但最终没能尝试就已离职。<br><img src="/img/4.png" alt="全栈开发"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天离职手续终于办完了，顺便回顾一下公司这几年研发技术的发展。</p>
<h2 id="asp-net_webform"><a href="#asp-net_webform" class="headerlink" title="asp.net webform"></a>as]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript的面向对象编程]]></title>
    <link href="http://binyanbin.github.io/2016/02/21/javascript-base-3/"/>
    <id>http://binyanbin.github.io/2016/02/21/javascript-base-3/</id>
    <published>2016-02-20T16:00:00.000Z</published>
    <updated>2016-02-27T16:33:03.403Z</updated>
    <content type="html"><![CDATA[<p>Javascript里的所有东西都是对象，可是它又不并像Java,C#。不是严格意义上的OOP语言。但是它可以实现OOP的效果。但在之前你需要了解哪些关键的知识点?</p>
<h2 id="u5173_u952E_u77E5_u8BC6_u70B9"><a href="#u5173_u952E_u77E5_u8BC6_u70B9" class="headerlink" title="关键知识点"></a>关键知识点</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>我们看下面这个使用this的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"yanbin"</span>,</span><br><span class="line">    showName :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> other =&#123;</span><br><span class="line">    name:<span class="string">"changsha"</span>,</span><br><span class="line">    showName:obj.showName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>obj.showName()提示的是yanbin,obj.showName()提示的是changsha，this是指执行时当前的对象。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行时函数不属于任何对象时,this表示window。(使用var定义的对象也属于window)</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>在Javascript中,new一个函数它做了以下3件事:</p>
<ul>
<li>创建新对象。</li>
<li>拷贝prototype到新对象。</li>
<li>设置构造函数</li>
<li>执行函数返回给新对象。<br>请看下面这个示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'yanbin'</span>;</span><br><span class="line">    <span class="keyword">this</span>.showcity =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	alert(<span class="string">'changsha'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span>  model =<span class="keyword">new</span> func();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过代码还原new的步骤<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newobj = &#123;&#125;;</span><br><span class="line">newobj.__proto__ = func.prototype;</span><br><span class="line">func.prototype.constructor = func;</span><br><span class="line">p.apply(newobj)</span><br><span class="line"><span class="keyword">var</span> model = newobj;</span><br></pre></td></tr></table></figure></p>
<p>这段代码我们需要搞清楚二个属性:</p>
<ul>
<li>prototype:在定义一个新函数，都会给函数创建一个prototype属性，也就是原型对象，把它看成普通对象也行了，但它可以影响这个函数实例的<strong>protype</strong>.</li>
<li>__protype__:是函数实例的原型对象指针，每次new一个函数的时候都会给实例生成一个指针newobj.__proto__=func.protype。当函数的原型对象改变时，那么实例也会发生改变，因为__proto__只是指针，所以它也不能修改，只能对应的原型方法或属性访问它。<br>弄清楚了这些我们就可以开始OPP实践了。</li>
</ul>
<h2 id="u5C01_u88C5_u793A_u4F8B"><a href="#u5C01_u88C5_u793A_u4F8B" class="headerlink" title="封装示例"></a>封装示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name,sex,s</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name =name;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayname</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        alert(<span class="string">"my name is "</span>+ name +<span class="string">", i'm a "</span>+sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.say =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        sayname();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> secret = s;</span><br><span class="line">    <span class="keyword">this</span>.getsecret = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setsecret = <span class="function"><span class="keyword">function</span>(<span class="params">ss</span>)</span>&#123;</span><br><span class="line">        secret = ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> model =<span class="keyword">new</span> Person(<span class="string">'yanbin'</span>,<span class="string">'man'</span>,<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure>
<p>name,sex是公开属性,sayname是一个私有方法，say是一个公共方法。secret是一个私有属性,对它的赋值和取值则是通过getsecret和setsecret这二个方法。</p>
<h2 id="u7EE7_u627F_u793A_u4F8B"><a href="#u7EE7_u627F_u793A_u4F8B" class="headerlink" title="继承示例"></a>继承示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">n</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        alert(<span class="string">"my name is:"</span>+ <span class="keyword">this</span>.realname);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">this</span>.realname = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.prototype = &#123;</span><br><span class="line">    realname : <span class="keyword">this</span>.realname,</span><br><span class="line">    say : <span class="keyword">this</span>.say</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">sex</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.getsex = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype = <span class="keyword">new</span> Man(<span class="string">'yanbin'</span>);</span><br><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> Employee(<span class="string">"female"</span>);</span><br></pre></td></tr></table></figure>
<p>Employee继承man的say方法和realname属性，Emplayee有一个私有属性sex和一个getsex方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Javascript里的所有东西都是对象，可是它又不并像Java,C#。不是严格意义上的OOP语言。但是它可以实现OOP的效果。但在之前你需要了解哪些关键的知识点?</p>
<h2 id="u5173_u952E_u77E5_u8BC6_u70B9"><a href="#u5173_u952E_u77E5_u8BC6_u70B9" class="headerlink" title="关键知识点"></a>关键知识点</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>我们看下面这个使用this的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"yanbin"</span>,</span><br><span class="line">    showName :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> other =&#123;</span><br><span class="line">    name:<span class="string">"changsha"</span>,</span><br><span class="line">    showName:obj.showName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>obj.showName()提示的是yanbin,obj.showName()提示的是changsha，this是指执行时当前的对象。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript的匿名函数]]></title>
    <link href="http://binyanbin.github.io/2016/02/20/javascript-base-2/"/>
    <id>http://binyanbin.github.io/2016/02/20/javascript-base-2/</id>
    <published>2016-02-19T16:00:00.000Z</published>
    <updated>2016-02-22T02:16:39.892Z</updated>
    <content type="html"><![CDATA[<p>匿名函数在javascript中非常常见且实用，它最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。javascript的框架这种用法随处可见。下面看二个例子，如何定义匿名函数。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">       alert(t);</span><br><span class="line">   &#125;;</span><br><span class="line">f(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure></p>
<p>“=”右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量f。通过f再调用这个匿名函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">	alert(t)</span><br><span class="line">   &#125;)(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。<br>这就是匿名函数常用的使用方式，通常用得最多的是第二种。</p>
<p>前端人员一般为了避免声明了一些全局变量而污染，把代码放在一个“沙箱执行”，然后在暴露出命名空间（可以为API，函数，对象）,如Jquery:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure>
<p>再如我想建一个自己的框架叫yb:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> yb = &#123;</span><br><span class="line">		add:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="string">"add"</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">		sub:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="string">"sub"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">window</span>.yb = yb;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>你的方法add和sub只能通过全局对象yb访问，这个是函数闭包规则决定的。如不能理解闭包请参见<a href="http://binyanbin.github.io/2016/01/03/javascript-base-1/">函数的闭包</a>;</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>匿名函数在javascript中非常常见且实用，它最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。javascript的框架这种用法随处可见。下面看二个例子，如何定义匿名函数。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[电商面试题]]></title>
    <link href="http://binyanbin.github.io/2016/02/18/interview-hishop/"/>
    <id>http://binyanbin.github.io/2016/02/18/interview-hishop/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-02-25T13:29:57.219Z</updated>
    <content type="html"><![CDATA[<p>15年年底去一家电商服务公司面试，其中有一道题目是如何解决电商站点商品秒杀的相关问题。<a href="https://github.com/hishopdc/dc2015" target="_blank" rel="external">面试题目可以参见</a>。固定的数据库结构下实现三个接口，查看、下单、付款。<br><a id="more"></a></p>
<h2 id="u4E3B_u8981_u95EE_u9898_3A_u9AD8_u5E76_u53D1_u67E5_u8BE2_u53CA_u66F4_u65B0_u6570_u636E_u5E93"><a href="#u4E3B_u8981_u95EE_u9898_3A_u9AD8_u5E76_u53D1_u67E5_u8BE2_u53CA_u66F4_u65B0_u6570_u636E_u5E93" class="headerlink" title="主要问题:高并发查询及更新数据库"></a>主要问题:高并发查询及更新数据库</h2><p>解决的方案其实比较其实并不复杂，也很常规。无非就是用缓存队列实现批量更新数据库。把下单的数据放入队列中，然后批量更新到数据库中去。说起来比较简单，实践中还是踩了一些坑。</p>
<h3 id="u4E3B_u8981_u5B9E_u73B0_u903B_u8F91"><a href="#u4E3B_u8981_u5B9E_u73B0_u903B_u8F91" class="headerlink" title="主要实现逻辑"></a>主要实现逻辑</h3><p>订单处理类<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 订单缓存队列处理类</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderCacheQuene</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 订单队列缓存</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Order&gt; _orders;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 数据库操作接口</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IPromotion _service;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 锁</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> _locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 队列处理线程</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread _thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 订单队列启动</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        _thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(OrderDispose));</span><br><span class="line">        _thread.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 缓存结束</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span> (_locker)</span><br><span class="line">        &#123;</span><br><span class="line">            _thread.Abort();</span><br><span class="line">            _service.OrderTrans(_orders);</span><br><span class="line">            _orders.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 下单</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">OrderBuy</span>(<span class="params">Order o</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span> (_locker)</span><br><span class="line">        &#123;</span><br><span class="line">            _orders.Add(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o.OrderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 支付</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">OrderPay</span>(<span class="params">RequestPay o, DateTime? paytime</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span> (_locker)</span><br><span class="line">        &#123;</span><br><span class="line">        	Order order = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> index = _orders.FindIndex(t =&gt; t.OrderId == o.order_id &amp;&amp; t.UserId == o.uid);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>)<span class="comment"><span class="xmlDocTag">///</span>已存在缓存中</span></span><br><span class="line">            &#123;</span><br><span class="line">                _orders[index].PayTime = paytime;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;            	</span><br><span class="line">            order = _service.GetOrder(o.order_id);</span><br><span class="line">            <span class="keyword">if</span> (order == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span><span class="comment"><span class="xmlDocTag">///</span>已存在数据库中</span></span><br><span class="line">            &#123;</span><br><span class="line">                order.PayTime = paytime;</span><br><span class="line">                <span class="keyword">lock</span> (_locker)</span><br><span class="line">                &#123;</span><br><span class="line">                    _orders.Add(order);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 判断队列是否已满</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isFull</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _orders.Count &gt;= Constant.QueueMaxCount ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 订单队列处理事件</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OrderDispose</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//DateTime starttime = DateTime.Now;</span></span><br><span class="line">            <span class="keyword">lock</span> (_locker)</span><br><span class="line">            &#123;</span><br><span class="line">               List&lt;Order&gt; orders =  _orders.Take(Constant.MaxOrderDispose).ToList();</span><br><span class="line">                _service.OrderTrans(orders.ToList());<span class="comment">//调用数据库接口处理订单</span></span><br><span class="line">                <span class="keyword">foreach</span> (Order o <span class="keyword">in</span> orders)</span><br><span class="line">                    _orders.Remove(o);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.Sleep(Constant.QueueDisposeTimeSpan);<span class="comment">//每次处理完成休眠</span></span><br><span class="line">            <span class="comment">//DateTime endtime = DateTime.Now;</span></span><br><span class="line">            <span class="comment">//System.Diagnostics.Debug.WriteLine("Yanbin TimeSpan:"+endtime.Subtract(starttime).Milliseconds);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存我直接使用的静态对像，效果是一样的。批量提交的方法是 _service.OrderTrans，在这里就不列出来，但是一些数据库操作。</p>
<p>订单队列启动与结束</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WebApiApplication : System.Web.HttpApplication</span><br><span class="line">&#123;</span><br><span class="line">    protected void Application_Start()</span><br><span class="line">    &#123;</span><br><span class="line">        //订单队列初始化</span><br><span class="line">        OrderCacheQuene.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void Application_End()</span><br><span class="line">    &#123;</span><br><span class="line">        //结束处理</span><br><span class="line">        OrderCacheQuene.End();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u57511_3A_u8D85_u5356"><a href="#u57511_3A_u8D85_u5356" class="headerlink" title="坑1:超卖"></a>坑1:超卖</h3><p>程序实现以后，我写了一个测试程序去跑它，跑到200线程时超卖了，思来想去之后发现是判断的问题，开始下单时的判断条件没有放到订单队列程序里面。因为并发大，所以有一些客户端请求下单的时候,程序判断是满足下单条件,但是还有一些客户端的请求正在响应，把订单加入缓存了，造成判断不一致，最终引起超卖。所以下单的条件判断需要加到锁里面，虽然对性能上有一些损耗，但是可以保证不会超卖。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 下单</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">OrderBuy</span>(<span class="params">Order o</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lock</span> (_locker)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span> (队列已满，已卖空，已下单等条件)</span><br><span class="line">     	<span class="keyword">return</span> <span class="keyword">null</span>;            	</span><br><span class="line">        _orders.Add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.OrderId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u57512_3A_u6548_u7387_u5751"><a href="#u57512_3A_u6548_u7387_u5751" class="headerlink" title="坑2:效率坑"></a>坑2:效率坑</h3><p>做web接口，在.net的系统中当然用webapi,更种好处用过都知道，没想到在高并发的条件下效率不如handler。以下这些数据是在我这台旧的笔记本上测试出来的。</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程调用接口数</th>
<th>处理方式</th>
<th>说明</th>
<th>产生订单数</th>
<th>接口方式</th>
<th>完成时间(秒)</th>
<th>完成时间(分钟)</th>
<th>处理请求总数</th>
<th>平均每秒处理请求</th>
</tr>
</thead>
<tbody>
<tr>
<td>2000</td>
<td>100</td>
<td>只查询</td>
<td>2000人同时查100种商品</td>
<td>0</td>
<td>handler</td>
<td>650.5</td>
<td>10.84</td>
<td>199706</td>
<td>307.004</td>
</tr>
<tr>
<td>2000</td>
<td>100</td>
<td>只查询</td>
<td>2000人同时查100种商品</td>
<td>0</td>
<td>api</td>
<td>1180.8</td>
<td>19.68</td>
<td>199747</td>
<td>169.162</td>
</tr>
<tr>
<td>1000</td>
<td>50</td>
<td>只查询</td>
<td>1000人同时查50种商品</td>
<td>0</td>
<td>handler</td>
<td>86.3</td>
<td>1.44</td>
<td>49932</td>
<td>578.586</td>
</tr>
<tr>
<td>1000</td>
<td>50</td>
<td>只查询</td>
<td>1000人同时查50种商品</td>
<td>0</td>
<td>api</td>
<td>103.9</td>
<td>1.73</td>
<td>49948</td>
<td>480.731</td>
</tr>
<tr>
<td>2000</td>
<td>10</td>
<td>抢购</td>
<td>2000人抢100个订单</td>
<td>100</td>
<td>handler</td>
<td>81.9</td>
<td>1.37</td>
<td>40430</td>
<td>493.651</td>
</tr>
<tr>
<td>2000</td>
<td>10</td>
<td>抢购</td>
<td>2000人抢100个订单</td>
<td>100</td>
<td>api</td>
<td>79.7</td>
<td>1.33</td>
<td>28738</td>
<td>360.577</td>
</tr>
<tr>
<td>2000</td>
<td>50</td>
<td>并发购买</td>
<td>50个人同时买2000种不同商品</td>
<td>100000</td>
<td>Handler</td>
<td>3467</td>
<td>57.78299471</td>
<td>86.378</td>
</tr>
<tr>
<td>2000</td>
<td>50</td>
<td>并发购买</td>
<td>50个人同时买2000种不同商品</td>
<td>100000</td>
<td>api</td>
<td>3638</td>
<td>60.63</td>
<td>299375</td>
<td>82.291</td>
</tr>
</tbody>
</table>
<p>从上图可以看出，在高并发情况下webapi的性能确实不行。</p>
<h3 id="u5F00_u53D1_u603B_u7ED3"><a href="#u5F00_u53D1_u603B_u7ED3" class="headerlink" title="开发总结"></a>开发总结</h3><ul>
<li>锁在高并发的情况下的使用，如何满足业务要求。</li>
<li>缓存的使用，缓存与数据库之间的数据如何保持一致。</li>
<li>对于大型电商网站，缓存队列需要设置上限，不然会引起内存问题，不过在这里不是这道题目的重点。</li>
</ul>
<p><a href="https://github.com/binyanbin/interview/" target="_blank" rel="external">源码下载</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>15年年底去一家电商服务公司面试，其中有一道题目是如何解决电商站点商品秒杀的相关问题。<a href="https://github.com/hishopdc/dc2015">面试题目可以参见</a>。固定的数据库结构下实现三个接口，查看、下单、付款。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript的闭包]]></title>
    <link href="http://binyanbin.github.io/2016/01/03/javascript-base-1/"/>
    <id>http://binyanbin.github.io/2016/01/03/javascript-base-1/</id>
    <published>2016-01-02T16:00:00.000Z</published>
    <updated>2016-02-21T14:51:30.124Z</updated>
    <content type="html"><![CDATA[<p>闭包是Javascript的一个重点的概念，在开发过程中用得非常多，但是在了解闭包之前我们需要了解全局与局部的概念，下面来看这个例子。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">myfun</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">   	<span class="keyword">var</span> my = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">infun</span>(<span class="params"></span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="keyword">in</span> = <span class="number">2</span>;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">innerfun</span>(<span class="params"></span>)</span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> inner = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">infun2</span>(<span class="params"></span>)</span><br><span class="line">   ｛</span><br><span class="line">	｝</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title">function</span> <span class="title">myfun2</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个三层嵌套的函数。我对局部的了解是指函数的内部，局部对像就是指函数内部的变量及函数。全局对象就是没有定义在任何函数内的变量和函数。全局对象是window的子对象。</p>
<p>在上面的这个程序中，全局对象有:<br><em>global变量
</em>myfun函数<br>*myfun2函数</p>
<p>myfun的内部对像有:<br><em>my变量
</em>infun函数<br>*infun2函数</p>
<p>infun的内部对像有:<br><em>in变量
</em>innerfun函数<br>以此类推。</p>
<p>了解了局部与全局后，闭包就容易了解,它是指内层函数可以使用外层函数局部对象，外层函数不能使用内层函数的局部对象，这种规则就叫函数的闭包。<br>从上面这个例子，我们就清楚在innerfun函数中，可以访问当前所有对像，因为它是最内层函数。而在infun函数中除了innerfun函数和它的内部变量inner不能访问外，其它的也都可以访问。<br>大家都可以访问全局对象，因为它在最外层。这就是为什么很多js库总是建一个对象放到window下做全局对象，你只要引用就可以访问到它。</p>
<p>补充:没有使用var进行定义的变量也是全局对象。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfun</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> part =<span class="string">"part variable"</span>;</span><br><span class="line">    global  =<span class="string">"global variable"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>闭包是Javascript的一个重点的概念，在开发过程中用得非常多，但是在了解闭包之前我们需要了解全局与局部的概念，下面来看这个例子。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何用hexo上做个blog站点]]></title>
    <link href="http://binyanbin.github.io/2016/01/02/hello-world/"/>
    <id>http://binyanbin.github.io/2016/01/02/hello-world/</id>
    <published>2016-01-01T16:00:00.000Z</published>
    <updated>2016-02-20T02:09:40.357Z</updated>
    <content type="html"><![CDATA[<p>2016年起，我要写博客了!各种博客网站都不合我意，最后用hexo+github搭了一个博客网站，全免费，还可以把开源项目放在里面，关键完全可以自己控制，入门虽然有一点难度，但是熟习以后使用起来其实相当简单. <a href="http://hexo.io/docs/" target="_blank" rel="external">了解关于hexo更多信息</a>. <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">hexo常见问题</a> 你也可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>上提问.</p>
<h2 id="u5F00_u542F"><a href="#u5F00_u542F" class="headerlink" title="开启"></a>开启</h2><h3 id="u521B_u5EFA_u65B0blog"><a href="#u521B_u5EFA_u65B0blog" class="headerlink" title="创建新blog"></a>创建新blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a><br><a id="more"></a></p>
<h3 id="u542F_u52A8web_u670D_u52A1_u5668"><a href="#u542F_u52A8web_u670D_u52A1_u5668" class="headerlink" title="启动web服务器"></a>启动web服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="u751F_u6210_u9759_u6001_u6587_u4EF6"><a href="#u751F_u6210_u9759_u6001_u6587_u4EF6" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="u53D1_u5E03_u7AD9_u70B9"><a href="#u53D1_u5E03_u7AD9_u70B9" class="headerlink" title="发布站点"></a>发布站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>一切看上去就是那么简单。但是用hexo做博客网站，你还需要懂一点nodejs,markdown语法，如果你想把网站放到github上，你还需要了解点git shell。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2016年起，我要写博客了!各种博客网站都不合我意，最后用hexo+github搭了一个博客网站，全免费，还可以把开源项目放在里面，关键完全可以自己控制，入门虽然有一点难度，但是熟习以后使用起来其实相当简单. <a href="http://hexo.io/docs/">了解关于hexo更多信息</a>. <a href="http://hexo.io/docs/troubleshooting.html">hexo常见问题</a> 你也可以在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上提问.</p>
<h2 id="u5F00_u542F"><a href="#u5F00_u542F" class="headerlink" title="开启"></a>开启</h2><h3 id="u521B_u5EFA_u65B0blog"><a href="#u521B_u5EFA_u65B0blog" class="headerlink" title="创建新blog"></a>创建新blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html">Writing</a><br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于博客]]></title>
    <link href="http://binyanbin.github.io/2015/12/20/self-introduce/"/>
    <id>http://binyanbin.github.io/2015/12/20/self-introduce/</id>
    <published>2015-12-19T16:00:00.000Z</published>
    <updated>2016-03-05T17:17:53.915Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2"><a href="#u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2" class="headerlink" title="为什么建这个博客"></a>为什么建这个博客</h2><p>其实很早的时候我写过博客，是在第三方网站上，当时的博客网站系统排个版都让我很头疼，可能也是因为不太熟习怎么用，最后坚持了一小会就放弃了。今年准备换工作，所以15年底去了几家公司面试，面对一堆的笔试，面试，机试各种试，感觉很累。想想原因，还是用人单位不了解你，就算你一份简历吹上天，也很难让用人单位相信你，你又没有人推荐。为了让我这把老骨头不在那么折腾,今年我一定要写博客，一定要做或者参与开源项目。<br><a id="more"></a></p>
<h2 id="u5173_u4E8E_u6211"><a href="#u5173_u4E8E_u6211" class="headerlink" title="关于我"></a>关于我</h2><table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:left">严彬</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">年龄</td>
<td style="text-align:left">34</td>
</tr>
<tr>
<td style="text-align:left">居住地</td>
<td style="text-align:left">长沙</td>
</tr>
</tbody>
</table>
<p>在IT行业差不多干了12年，最近的一家公司呆了8年，做了5年技术管理之后，16年初离职，现在在一家电商服务公司。</p>
<h2 id="u535A_u5BA2_u76F8_u5173"><a href="#u535A_u5BA2_u76F8_u5173" class="headerlink" title="博客相关"></a>博客相关</h2><ul>
<li>博客android app安装<a href="http://binyanbin.github.io/apk/binyanbin.apk">下载</a></li>
<li>获取android app<a href="http://binyanbin.github.io/apk/versioninfo.xml">版本数据</a></li>
<li>获取博客<a href="http://binyanbin.github.io/atom.xml">数据</a></li>
</ul>
<h2 id="u670D_u52A1"><a href="#u670D_u52A1" class="headerlink" title="服务"></a>服务</h2><ul>
<li>承接长沙当地企业技术培训及咨询工作。</li>
</ul>
<p>QQ:8999482 邮箱:yanbin.yb@hotmail.com 欢迎骚扰。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2"><a href="#u4E3A_u4EC0_u4E48_u5EFA_u8FD9_u4E2A_u535A_u5BA2" class="headerlink" title="为什么建这个博客"></a>为什么建这个博客</h2><p>其实很早的时候我写过博客，是在第三方网站上，当时的博客网站系统排个版都让我很头疼，可能也是因为不太熟习怎么用，最后坚持了一小会就放弃了。今年准备换工作，所以15年底去了几家公司面试，面对一堆的笔试，面试，机试各种试，感觉很累。想想原因，还是用人单位不了解你，就算你一份简历吹上天，也很难让用人单位相信你，你又没有人推荐。为了让我这把老骨头不在那么折腾,今年我一定要写博客，一定要做或者参与开源项目。<br>]]>
    
    </summary>
    
  </entry>
  
</feed>
